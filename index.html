<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>7cthunder</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="7cthunder">
<meta property="og:url" content="https://7cthunder.github.io/index.html">
<meta property="og:site_name" content="7cthunder">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="7cthunder">
  
    <link rel="alternate" href="/atom.xml" title="7cthunder" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">7cthunder</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">这段代码我已经和小黄鸭商量过了。</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://7cthunder.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-SWAD-Homework3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/13/SWAD-Homework3/" class="article-date">
  <time datetime="2019-04-13T09:16:27.000Z" itemprop="datePublished">2019-04-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/SWAD/">SWAD</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/13/SWAD-Homework3/">SWAD | Homework3</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="简述瀑布模型、增量模型、螺旋模型（含原型方法），并分析优缺点"><a href="#简述瀑布模型、增量模型、螺旋模型（含原型方法），并分析优缺点" class="headerlink" title="简述瀑布模型、增量模型、螺旋模型（含原型方法），并分析优缺点"></a>简述瀑布模型、增量模型、螺旋模型（含原型方法），并分析优缺点</h2><blockquote>
<p>从项目特点、风险特征、人力资源利用角度思考</p>
<p>(以下部分为个人观点)</p>
</blockquote>
<h3 id="瀑布模型"><a href="#瀑布模型" class="headerlink" title="瀑布模型"></a>瀑布模型</h3><p>瀑布模型将软件生命周期划分为制定计划、分析、设计、编码、测试、运行维护等阶段，其规定了上述阶段必须自上而下，像瀑布一样。本阶段活动的工作对象来自于上一项活动的输出，这些输出一般是代表本阶段活动结束的里程碑式的文档，本阶段活动产出相关的软件工件，作为下一阶段活动的输入。改进的瀑布模型可以在下游阶段发现缺陷后返回上一个阶段，或者如果下游阶段认为不足则返回到设计阶段。</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol>
<li>降低软件开发的复杂程度，提高软件开发过程的透明性，提高软件开发过程的可管理性，可适用于大型项目</li>
<li>不同人员可以只根据上一阶段的文档，进行本阶段的工作，有利于人员的组织和管理  </li>
</ol>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li>缺乏灵活性，尤其无法解决软件需求不明确或不准确的问题</li>
<li>风险控制能力较弱</li>
<li>管理人员如果仅仅以文档的完成情况来评估项目完成进度，往<br>往会产生错误的结论</li>
</ol>
<h3 id="增量模型"><a href="#增量模型" class="headerlink" title="增量模型"></a>增量模型</h3><p>增量模型采用随着日程时间的进展而交错的线性序列，每一个线性序列产生软件的一个可发布的“增量”。其首先对系统最核心或最清晰的需求进行分析、设计、实现、测试并集成到系统中，再按优先级逐步实现后续需求。增量模型强调每一个增量均发布一个可操作的产品。</p>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ol>
<li>提高系统可靠性</li>
<li>降低系统失败风险</li>
<li>通过同一个团队的工作来交付每个增量，保持所有团队处于工作状态，减少了员工的工作量，工作分布曲线通过项目中的时间阶段被拉平。</li>
</ol>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li>建立初始模型时，作为增量基础的基本业务服务的确定有一定难度</li>
<li>增量粒度难以选择</li>
</ol>
<h3 id="螺旋模型"><a href="#螺旋模型" class="headerlink" title="螺旋模型"></a>螺旋模型</h3><p>螺旋模型结合了瀑布模型和快速原型方法，将瀑布模型的多个阶段转化到多个迭代过程中，以降低项目的风险。螺旋模型最大的特点在于引入了其他模型不具有的风险分析，使软件在无法排除重大风险时有机会停止，以减小损失。同时，在每个迭代阶段构建原型是螺旋模型用以减少风险的途径。螺旋模型的每一次迭代都包含了以下六个步骤：</p>
<ul>
<li>决定目标、替代方案和约束条件</li>
<li>识别和解决项目的风险</li>
<li>评估技术方案和替代方案</li>
<li>开发本次迭代的交付物，并验证迭代产出的正确性</li>
<li>计划下一次迭代</li>
<li>提交下一次迭代的步骤和方案</li>
</ul>
<h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><ol>
<li>整体过程具备很高的灵活性，在开发过程的任何阶段自由应对变化</li>
<li>引入风险分析，使软件在无法排除重大风险时有机会停止，以减小损失</li>
</ol>
<h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li>螺旋模型强调风险分析，但说服外部客户接受和相信分析结果并做出相关反应并不容易，因此螺旋模型往往比较适合内部的大规模软件开发。</li>
<li>风险分析需要耗费相当的成本，因此螺旋模型比较适合投资规模较大的软件项目。</li>
<li>失误的风险分析可能带来更大的风险。</li>
</ol>
<h2 id="简述统一过程三大特点，与面向对象的方法有什么关系？"><a href="#简述统一过程三大特点，与面向对象的方法有什么关系？" class="headerlink" title="简述统一过程三大特点，与面向对象的方法有什么关系？"></a>简述统一过程三大特点，与面向对象的方法有什么关系？</h2><h3 id="三大特点"><a href="#三大特点" class="headerlink" title="三大特点"></a>三大特点</h3><ol>
<li>用例驱动：用例驱动表明开发过程是沿着一个流（一系列从用例得到的工作流）前进的：用例被确定、用例被设计、用例被测试（最后用例又成为测试人员构造测试用例的基础）</li>
<li>以架构为中心：软件构架包含了系统中最重要的静态和动态特征。构架刻画了系统的整体设计，去掉了细节部分，突出了系统的重要特性。</li>
<li>迭代和增量的：软件开发是一项复杂的过程，因此可以将这些项目划分为切实可行并能够产生一个增量的迭代过程。迭代是指工作流中的步骤，增量是指产品中增加的部分。</li>
</ol>
<p>它将软件开发过程要素和软件工件要素整合在统一的软件工程框架中，是一个面向对象的程序开发方法论。</p>
<h2 id="简述统一过程四个阶段的划分准则是什么？每个阶段关键的里程碑是什么？"><a href="#简述统一过程四个阶段的划分准则是什么？每个阶段关键的里程碑是什么？" class="headerlink" title="简述统一过程四个阶段的划分准则是什么？每个阶段关键的里程碑是什么？"></a>简述统一过程四个阶段的划分准则是什么？每个阶段关键的里程碑是什么？</h2><p>统一过程中的软件生命周期在时间维度上被分解为四个顺序的阶段：初始阶段 (Inception)、精化阶段 (Elaboration)、构建阶段(Construction) 和产品交付阶段 (Transition)。</p>
<ol>
<li>初始阶段 (Inception)：为系统建立业务案例 (Business Case) 并确定项目的边界。<ul>
<li>里程碑：生命周期目标 (Lifecycle Objective) 里程碑，包括一些重要的文档，如：项目构想 (Vision)、原始用例模型、原始业务风险评估、一个或者多个原型、原始业务案例等。通过对文档的评审确定用例需求理解正确、项目风险评估合理、阶段计划可行等</li>
</ul>
</li>
<li>精化阶段 (Elaboration)：分析问题领域，建立健全的体系结构基础，编制项目计划，完成项目中高风险需求部分的开发。<ul>
<li>里程碑：生命周期体系结构 (Lifecycle Architecture) 里程碑，包括风险分析文档、软件体系结构基线、项目计划、可执行的进化原型、初始版本的用户手册等。通过评审确定软件体系结构已经稳定、高风险的业务需求和技术机制已经解决、修订的项目计划可行等。</li>
</ul>
</li>
<li>构建阶段(Construction)：完成所有剩余的技术构件和稳定业务需求功能的开发，并集成为产品，详细测试所有功能。构建阶段只是一个制造过程，其重点放在管理资源及控制开发过程以优化成本、进度和质量。<ul>
<li>里程碑：初始运行能力 (Initial Operational Capability) 里程碑，包括可以运行的软件产品、用户手册等，它决定了产品是否可以在测试环境中进行部署。此刻，要确定软件、环境、用户是否可以开始系统的运行。</li>
</ul>
</li>
<li>产品交付阶段 (Transition)：确保软件对最终用户是可用的。产品化阶段可以跨越几次迭代，包括为发布做准备的产品测试，基于用户反馈的少量调整。<ul>
<li>里程碑：产品发布 (Product Release) 里程碑，确定最终目标是否实现，是否应该开始产品下一个版本的另一个开发周期。在一些情况下这个里程碑可能与下一个周期的初始阶段相重合。</li>
</ul>
</li>
</ol>
<h2 id="软件企业为什么能按固定节奏生产、固定周期发布软件产品？它给企业项目管理带来哪些好处？"><a href="#软件企业为什么能按固定节奏生产、固定周期发布软件产品？它给企业项目管理带来哪些好处？" class="headerlink" title="软件企业为什么能按固定节奏生产、固定周期发布软件产品？它给企业项目管理带来哪些好处？"></a>软件企业为什么能按固定节奏生产、固定周期发布软件产品？它给企业项目管理带来哪些好处？</h2><p>统一过程为企业按固定节奏生产、固定周期发布软件产品提供了依据。</p>
<p>统一过程中的软件生命周期在时间维度上被分解为四个顺序的阶段：初始阶段 (Inception)、精化阶段 (Elaboration)、构建阶段(Construction) 和产品交付阶段 (Transition)，可以使企业能有一个固定的节奏来生产；统一过程的迭代性，使得项目组能周期性地交付产品。</p>
<p>给企业项目管理带来的好处：</p>
<ol>
<li>在软件开发的早期就可以对关键的，影响大的风险进行处理</li>
<li>可以提出一个软件体系架构来指导开发</li>
<li>可以较早的得到一个可运行的系统，鼓舞开发团队的士气，增强项目成功的信心。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://7cthunder.github.io/2019/04/13/SWAD-Homework3/" data-id="cjufi5t5e00067zrps7la6up2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SWAD/">SWAD</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-SWAD-Homework2-md" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/12/SWAD-Homework2-md/" class="article-date">
  <time datetime="2019-04-12T09:36:12.000Z" itemprop="datePublished">2019-04-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/SWAD/">SWAD</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/12/SWAD-Homework2-md/">SWAD | Homework2</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="简答题"><a href="#简答题" class="headerlink" title="简答题"></a>简答题</h2><h3 id="用简短的语言给出对分析、设计的理解"><a href="#用简短的语言给出对分析、设计的理解" class="headerlink" title="用简短的语言给出对分析、设计的理解"></a>用简短的语言给出对分析、设计的理解</h3><ul>
<li>分析：对问题和需求的进行调查研究，关注系统需要”实现什么”</li>
<li>设计：定义系统或组件的体系结构、组件、接口和其他特征的过程。</li>
</ul>
<h3 id="用一句话描述面向对象的分析与设计的优势"><a href="#用一句话描述面向对象的分析与设计的优势" class="headerlink" title="用一句话描述面向对象的分析与设计的优势"></a>用一句话描述面向对象的分析与设计的优势</h3><p>面向对象的分析与设计让不同领域的人沟通更加地方便，系统更加简单易懂，因此更容易维护复用。</p>
<h3 id="简述-UML（统一建模语言）的作用"><a href="#简述-UML（统一建模语言）的作用" class="headerlink" title="简述 UML（统一建模语言）的作用"></a>简述 UML（统一建模语言）的作用</h3><p>UML（统一建模语言）是软件工程领域中一种通用的、开发的、建模语言，旨在可视化系统分析与设计的结果</p>
<h4 id="考试考哪些图"><a href="#考试考哪些图" class="headerlink" title="考试考哪些图"></a>考试考哪些图</h4><ul>
<li>用例图：用户角度：功能、执行者 </li>
<li>静态图：系统静态结构 <ul>
<li>类图：概念及关系 </li>
<li>对象图：某种状态或时间段内，系统中活跃的对象及其关系 </li>
<li>包图：描述系统的分解结构 </li>
</ul>
</li>
<li>行为图：系统的动态行为 <ul>
<li>交互图：描述对象间的消息传递<ul>
<li>顺序图：强调对象间消息发送的时序 </li>
<li>合作图：强调对象间的动态写作关系 </li>
</ul>
</li>
<li>状态图：对象的动态行为。状态 - 事件 - 状态迁移 - 响应动作 </li>
<li>活动图：描述系统为完成某功能而执行的操作序列 </li>
</ul>
</li>
<li>实现图：描述系统的组成和分布状况 <ul>
<li>构件图：组成部件及其关系 </li>
<li>部署图：物理体系结构及与软件单元的对应关系</li>
</ul>
</li>
</ul>
<h3 id="从软件本质的角度，解释软件范围（需求）控制的可行性"><a href="#从软件本质的角度，解释软件范围（需求）控制的可行性" class="headerlink" title="从软件本质的角度，解释软件范围（需求）控制的可行性"></a>从软件本质的角度，解释软件范围（需求）控制的可行性</h3><p>由于软件本身的复杂性、不可见性、不一致性、可变性，软件范围多数情况下对于客户和开发者都是模糊的，这形成软件产品与其他产品不同的开发过程。在多数情况下，客户与开发者能就项目的 20% 内容给出严格的需求约定，80% 的内容都是相对模糊的。换言之，围绕客户目标，发现并满足客户感兴趣的内容是最关键的，这表示软件范围控制是可行的。</p>
<h2 id="项目管理实践"><a href="#项目管理实践" class="headerlink" title="项目管理实践"></a>项目管理实践</h2><h3 id="看板使用练习"><a href="#看板使用练习" class="headerlink" title="看板使用练习"></a>看板使用练习</h3><p><img src="https://github.com/7cthunder/7cthunder.github.io/raw/master/assets/kanban.png" alt="image-20190412140818437"></p>
<h3 id="UML绘图工具练习"><a href="#UML绘图工具练习" class="headerlink" title="UML绘图工具练习"></a>UML绘图工具练习</h3><p><img src="https://github.com/7cthunder/7cthunder.github.io/raw/master/assets/umlet.png" alt></p>
<p>选自教材P49 Figure 1.5</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://7cthunder.github.io/2019/04/12/SWAD-Homework2-md/" data-id="cjufi5t5b00027zrptrfb3wds" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SWAD/">SWAD</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-SWAD-Homework1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/13/SWAD-Homework1/" class="article-date">
  <time datetime="2019-03-13T15:28:10.000Z" itemprop="datePublished">2019-03-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/SWAD/">SWAD</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/13/SWAD-Homework1/">SWAD | Homework1</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="简答题"><a href="#简答题" class="headerlink" title="简答题"></a>简答题</h2><ul>
<li><p>软件工程的定义</p>
<p>软件工程是研究和应用如何以系统性的、规范化的、可定量的过程化方法去开发和维护软件，以及如何把经过时间考验而证明正确的管理技术和当前能够得到的最好的技术方法结合起来的学科。它涉及到程序设计语言、数据库、软件开发工具、系统平台、标准、设计模式等方面。</p>
</li>
<li><p>解释导致 software crisis 本质原因、表现，述说克服软件危机的方法</p>
<ul>
<li>本质原因：由于软件的大量需求与软件生产力效率之间的矛盾以及软件系统的复杂性与软件开发方法之间的矛盾</li>
<li>表现：<ul>
<li>项目运行超出预算</li>
<li>项目运行超过时间</li>
<li>软件质量低落</li>
<li>软件通常不匹配需求</li>
<li>项目无法管理，且代码难以维护</li>
</ul>
</li>
<li>克服软件危机的方法：<ul>
<li>借鉴其他工程项目中行之有效的原理、概念、技术与方法，特别是吸取人类从事计算机硬件研究和开发的经验教训。在开发软件的过程中做到良好的组织，严格的管理，相互友好的协作。</li>
<li>推广在实践中总结出来的开发软件的成功的技术和方法，并研究更好、更有效的技术和方法，尽快克服在计算机系统早期发展阶段形成的一些错误概念和做法。</li>
<li>根据不同的应用领域，开发更好的软件工具并使用这些工具。将软件开发各个阶段使用的软件工具合成一个整体，形成一个良好的软件开发环境。</li>
</ul>
</li>
</ul>
</li>
<li><p>软件生命周期</p>
<p>在时间维度，对软件项目任务进行划分，又成为软件开发过程。常见有瀑布模型、螺旋模型、敏捷的模型等。</p>
</li>
<li><p>SWEBoK 的 15 个知识域</p>
<ul>
<li><p>Software Requirements 软件需求</p>
<p>软件需求表达了对软件产品的需求和约束，这些需求和约束有助于解决一些实际问题。</p>
</li>
<li><p>Software Design 软件设计</p>
<p>设计是定义系统或组件的体系结构、组件、接口和其他特征的过程、以及该过程的结果。</p>
</li>
<li><p>Software Construction 软件构造</p>
<p>通过详细设计、编码、单元测试、集成测试、调试和验证相结合，对工作软件进行详细的创建。</p>
</li>
<li><p>Software Testing 软件测试</p>
<p>为了验证产品质量并且通过指出缺陷来增进软件质量的活动。</p>
</li>
<li><p>Software Maintenance 软件维护</p>
<p>包括增强现有的功能，使得软件在新的环境中运行以及修正缺陷。</p>
</li>
<li><p>Software Configuration Management 软件配置管理</p>
<p>软件配置管理(Software Configuration Management)： 系统的配置是硬件、固件、软件或它们的组合的功能和/或物理特征。它还可以看作是硬件、固件或软件项目的特定版本的集合，为了服务于特定的目的，将这些硬件、固件和软件项目根据特定的构建过程组合在一起。因此，软件配置管理(SCM)是在不同的时间点识别系统配置的规程，以便系统地控制配置的更改，并在整个软件生命周期中维护配置的完整性和可追溯性。</p>
</li>
<li><p>Software Engineering Management 软件工程管理</p>
<p>包括计划、协调、测量、报告和控制一个项目或程序，确保软件的开发和维护是系统的、规范化的、可定量的。</p>
</li>
<li><p>Software Engineering Process 软件工程过程</p>
<p>软件工程知识领域关注软件生命周期过程的定义，实现，评估，测量，管理和改进。主题包括过程实现和改变(过程基础设施，过程实现和改变模型，和软件过程管理)，过程定义(软件生命周期模型和过程，过程定义，过程适应和自动化过程的符号)，过程评估模型和方法，测量(过程测量，产品测量，技术测量和测量结果质量)和软件过程工具。</p>
</li>
<li><p>Software Engineering Models and Methods 软件工程模型和方法</p>
<p>软件工程技术和管理的原理、原则、方法</p>
</li>
<li><p>Software Quality 软件质量</p>
<p>软件质量是软件生命周期普遍关注的，存在于许多 SWEBOK V3 知识领域中。此外，软件质量知识领域包括软件质量基础(软件工程文化，软件质量特征，软件质量价值和成本和软件质量改进)，软件质量管理过程(软件质量保证，认证和确认，审核和审计)和实际考量(缺陷特征，软件质量测量和软件质量工具)。</p>
</li>
<li><p>Software Engineering Professional Practice 软件工程专业实践</p>
<p>软件工程专业实践关注软件工程师必须具备的知识，技巧和态度，以用一种专业，负责和正直的态度来时间软件工程。软件工程专业实践知识领域涵盖专业性(专业行为，专业协会，软件工程标准，雇佣合同和法律问题)，道德准则，动态小组(团队合作，认知问题复杂性，与利益相关者交互，不确定性和模糊性的处理，多元环境处理)和交流技巧。</p>
</li>
<li><p>Software Engineering Economics 软件工程经济学</p>
<p>软件工程经济学知识领域关注在商业环境中做出决策，以使技术决策和商业目标达成一致。</p>
</li>
<li><p>Computing Foundations 计算基础</p>
<p>计算基础知识领域涵盖对于软件工程实践必须的计算背景的基础主题。涵盖主题包括问题解决技术，抽象，算法和复杂度，编程基础，并行和分布式计算基础，计算机组成，操作系统和网络通信。</p>
</li>
<li><p>Mathematical Foundations</p>
<p>数学基础知识领域涵盖对于软件工程实践必须的数学背景的基础主题。涵盖的主题包括集合，关系和函数，基础命题和谓词逻辑，证明技术，图和树，离散概率，语法和有限状态机，数论。</p>
</li>
<li><p>Engineering Foundations</p>
<p>工程基础知识领域涵盖对于软件工程实践必须的工程背景的基础主题。涵盖的主题包括经验方法和实验技术，统计分析，测量和指标，工程设计，模拟和建模，根本原因分析。</p>
</li>
</ul>
</li>
<li><p>CMMI 的五个级别</p>
<ul>
<li>Level 1 - Initial: 没有可预知的生产过程，缺乏控制和应变能力</li>
<li>Level 2 - Managed: 生产过程为每个项目特制，一般有一定的应变能力。</li>
<li>Level 3 - Defined: 生产过程为组织所定制，并且积极主动。</li>
<li>Level 4 - Quantitatively Managed: 生产过程可测度（预知）且可控。</li>
<li>Level 5 - Optimizing: 生产专注于过程优化。</li>
</ul>
</li>
<li><p>用自己语言简述 SWEBok 或 CMMI</p>
<p>CMMI 全称为能力成熟度模型集成，其本质上就是衡量软件工程的成熟度的五个级别。CMMI可以帮助企业确认当前软件工程处于的级别并且对其进行管理和改进，增强软件的开发和改进能力。其目的就在于使得软件可以在限定时间和预算内完成并且保证其高质量。CMMI分为五个级别，分别是无序、已管理、已定义、量化管理和优化，这五个级别对于软件工程的管理规范一级比一级要严格，是一个渐进性的模型框架，指导了企业对于现有的软件工程进行评估和改进以及开始新的系统性规范化的软件工程。其主要关注点在于：成本效益、明确重过程集中和灵活性。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://7cthunder.github.io/2019/03/13/SWAD-Homework1/" data-id="cjufi5t5600007zrpyfhb32p5" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SWAD/">SWAD</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-服务计算-gorilla-mux-源码解析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/15/服务计算-gorilla-mux-源码解析/" class="article-date">
  <time datetime="2018-11-15T11:29:55.000Z" itemprop="datePublished">2018-11-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Go/">Go</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/15/服务计算-gorilla-mux-源码解析/">服务计算 | gorilla/mux 源码解析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="gorilla-mux-源码解析"><a href="#gorilla-mux-源码解析" class="headerlink" title="gorilla/mux 源码解析"></a>gorilla/mux 源码解析</h1><p>在开始阅读 <code>gorilla/mux</code> 源码之前，不妨让我们看看 <code>Golang</code> 的 <code>net/http</code> 包是怎么实现多路复用的。</p>
<h2 id="net-http"><a href="#net-http" class="headerlink" title="net/http"></a>net/http</h2><p>用一个简单的例子过一下流程:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Hello world, the web server</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"io"</span></span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	helloHandler := <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">		io.WriteString(w, <span class="string">"Hello, world!\n"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	http.HandleFunc(<span class="string">"/hello"</span>, helloHandler)</span><br><span class="line">	log.Fatal(http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先我们调用了 <code>http.HandleFunc</code> 来为 <code>/hello</code> 注册一个 <code>Handler</code>：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.HandleFunc(<span class="string">"/hello"</span>, helloHandler)</span><br></pre></td></tr></table></figure></p>
<p>依次调用下面三个函数/方法，第一个函数表明当我们使用 http.HandleFunc 时默认是注册在 <code>DefaultServeMux</code> 这个默认的多路复用器上；第二个方法中 <code>HandlerFunc(handler)</code> 意思是将 <code>handler</code> 强制转化为 <code>HandlerFunc</code> 因为其实现了 <code>http.Handler</code> 这个接口；第三个方法在 mux.m 中查找是否已为该 <code>URL</code> 注册 <code>handler</code> ，如果有就报错，没有就为其注册：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ServeMux *</span></span><br><span class="line"><span class="keyword">type</span> ServeMux <span class="keyword">struct</span> &#123;</span><br><span class="line">	mu    sync.RWMutex</span><br><span class="line">	m     <span class="keyword">map</span>[<span class="keyword">string</span>]muxEntry</span><br><span class="line">	hosts <span class="keyword">bool</span> <span class="comment">// whether any patterns contain hostnames</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HandleFunc registers the handler function for the given pattern</span></span><br><span class="line"><span class="comment">// in the DefaultServeMux.</span></span><br><span class="line"><span class="comment">// The documentation for ServeMux explains how patterns are matched.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span>)</span> &#123;</span><br><span class="line">	DefaultServeMux.HandleFunc(pattern, handler)</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// HandleFunc registers the handler function for the given pattern.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span>)</span> &#123;</span><br><span class="line">	mux.Handle(pattern, HandlerFunc(handler))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Handle registers the handler for the given pattern.</span></span><br><span class="line"><span class="comment">// If a handler already exists for pattern, Handle panics.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">Handle</span><span class="params">(pattern <span class="keyword">string</span>, handler Handler)</span></span> &#123;</span><br><span class="line">	mux.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> mux.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> pattern == <span class="string">""</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"http: invalid pattern"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> handler == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"http: nil handler"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> _, exist := mux.m[pattern]; exist &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"http: multiple registrations for "</span> + pattern)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> mux.m == <span class="literal">nil</span> &#123;</span><br><span class="line">		mux.m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]muxEntry)</span><br><span class="line">	&#125;</span><br><span class="line">	mux.m[pattern] = muxEntry&#123;h: handler, pattern: pattern&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> pattern[<span class="number">0</span>] != <span class="string">'/'</span> &#123;</span><br><span class="line">		mux.hosts = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来是调用：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure></p>
<p>本文不打算追踪启动 <code>server</code> 的整个过程，不了解或者感兴趣的可以看看 <a href="https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/03.4.md" target="_blank" rel="noopener">Go的http包详解</a> 。我们只挑对我们讲解多路复用感兴趣的部分来讲解，下面看看：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sh serverHandler)</span> <span class="title">ServeHTTP</span><span class="params">(rw ResponseWriter, req *Request)</span></span> &#123;</span><br><span class="line">	handler := sh.srv.Handler</span><br><span class="line">	<span class="keyword">if</span> handler == <span class="literal">nil</span> &#123;</span><br><span class="line">		handler = DefaultServeMux</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> req.RequestURI == <span class="string">"*"</span> &amp;&amp; req.Method == <span class="string">"OPTIONS"</span> &#123;</span><br><span class="line">		handler = globalOptionsHandler&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	handler.ServeHTTP(rw, req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的方法表明当我们在调用 <code>http.ListenAndServe(&quot;:8080&quot;, nil)</code> 没有给 <code>handler</code> 的时候，默认使用 <code>DefaultServeMux</code> ，所以上面的例子调用的是 <code>DefaultServeMux</code> 的 <code>ServeHTTP</code>：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ServeHTTP dispatches the request to the handler whose</span></span><br><span class="line"><span class="comment">// pattern most closely matches the request URL.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">ServeHTTP</span><span class="params">(w ResponseWriter, r *Request)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> r.RequestURI == <span class="string">"*"</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> r.ProtoAtLeast(<span class="number">1</span>, <span class="number">1</span>) &#123;</span><br><span class="line">			w.Header().Set(<span class="string">"Connection"</span>, <span class="string">"close"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		w.WriteHeader(StatusBadRequest)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	h, _ := mux.Handler(r)</span><br><span class="line">	h.ServeHTTP(w, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>让我们看看 <code>DefaultServeMux</code> 是如何查找相应的 <code>handler</code> ，看看 <code>match</code> 的实现，只能简单地实现字符串匹配，用起来不够爽吧？<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Find a handler on a handler map given a path string.</span></span><br><span class="line"><span class="comment">// Most-specific (longest) pattern wins.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">match</span><span class="params">(path <span class="keyword">string</span>)</span> <span class="params">(h Handler, pattern <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// Check for exact match first.</span></span><br><span class="line">	v, ok := mux.m[path]</span><br><span class="line">	<span class="keyword">if</span> ok &#123;</span><br><span class="line">		<span class="keyword">return</span> v.h, v.pattern</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Check for longest valid match.</span></span><br><span class="line">	<span class="keyword">var</span> n = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> mux.m &#123;</span><br><span class="line">		<span class="keyword">if</span> !pathMatch(k, path) &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> h == <span class="literal">nil</span> || <span class="built_in">len</span>(k) &gt; n &#123;</span><br><span class="line">			n = <span class="built_in">len</span>(k)</span><br><span class="line">			h = v.h</span><br><span class="line">			pattern = v.pattern</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当然，复杂也可能意味着性能下降，有兴趣的同学可以看看 <a href="https://github.com/julienschmidt/go-http-routing-benchmark/blob/master/README.md" target="_blank" rel="noopener">Go HTTP Router Benchmark</a> ，毕竟系统是拿来用的，不只是拿来写的。不过作为一个合格的程序员，应该学会用轮子，所以让我们看看 <code>gorilla/mux</code> 是怎么实现路由的吧。</p>
<h2 id="gorilla-mux"><a href="#gorilla-mux" class="headerlink" title="gorilla/mux"></a>gorilla/mux</h2><p>一个简单使用的例子（摘自<a href="https://github.com/gorilla/mux#graceful-shutdown" target="_blank" rel="noopener">官方文档</a>）：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"github.com/gorilla/mux"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">YourHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    w.Write([]<span class="keyword">byte</span>(<span class="string">"Gorilla!\n"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := mux.NewRouter()</span><br><span class="line">    <span class="comment">// Routes consist of a path and a handler function.</span></span><br><span class="line">    r.HandleFunc(<span class="string">"/"</span>, YourHandler)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bind to a port and pass our router in</span></span><br><span class="line">    log.Fatal(http.ListenAndServe(<span class="string">":8000"</span>, r))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一些进阶用法：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以匹配 URL 中的变量</span></span><br><span class="line">r := mux.NewRouter()</span><br><span class="line">r.HandleFunc(<span class="string">"/products/&#123;key&#125;"</span>, ProductHandler)</span><br><span class="line">r.HandleFunc(<span class="string">"/articles/&#123;category&#125;/"</span>, ArticlesCategoryHandler)</span><br><span class="line">r.HandleFunc(<span class="string">"/articles/&#123;category&#125;/&#123;id:[0-9]+&#125;"</span>, ArticleHandler)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用匹配的变量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ArticlesCategoryHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    vars := mux.Vars(r)</span><br><span class="line">    w.WriteHeader(http.StatusOK)</span><br><span class="line">    fmt.Fprintf(w, <span class="string">"Category: %v\n"</span>, vars[<span class="string">"category"</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路径前缀</span></span><br><span class="line">r.PathPrefix(<span class="string">"/products/"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Only matches if domain is "www.example.com".</span></span><br><span class="line">r.Host(<span class="string">"www.example.com"</span>)</span><br><span class="line"><span class="comment">// Matches a dynamic subdomain.</span></span><br><span class="line">r.Host(<span class="string">"&#123;subdomain:[a-z]+&#125;.domain.com"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子路由</span></span><br><span class="line">r := mux.NewRouter()</span><br><span class="line">s := r.Host(<span class="string">"www.example.com"</span>).Subrouter()</span><br></pre></td></tr></table></figure></p>
<p>ok，总之它的功能比官方包要强大的多，下面开始源码分析。</p>
<h3 id="mux-go"><a href="#mux-go" class="headerlink" title="mux.go"></a>mux.go</h3><p>先看看其数据结构，与 <code>http.ServeMux</code> 相比，要多出不少东西，我们主要关注 <code>routes</code> 、<code>parent</code> 以及三个 <code>flag</code>：<code>strictSlash</code>、<code>skipClean</code>、<code>useEncodedPath</code>。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This will send all incoming requests to the router.</span></span><br><span class="line"><span class="keyword">type</span> Router <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// Configurable Handler to be used when no route matches.</span></span><br><span class="line">	NotFoundHandler http.Handler</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Configurable Handler to be used when the request method does not match the route.</span></span><br><span class="line">	MethodNotAllowedHandler http.Handler</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Parent route, if this is a subrouter.</span></span><br><span class="line">	parent parentRoute</span><br><span class="line">	<span class="comment">// Routes to be matched, in order.</span></span><br><span class="line">	routes []*Route</span><br><span class="line">	<span class="comment">// Routes by name for URL building.</span></span><br><span class="line">	namedRoutes <span class="keyword">map</span>[<span class="keyword">string</span>]*Route</span><br><span class="line">	<span class="comment">// See Router.StrictSlash(). This defines the flag for new routes.</span></span><br><span class="line">	strictSlash <span class="keyword">bool</span></span><br><span class="line">	<span class="comment">// See Router.SkipClean(). This defines the flag for new routes.</span></span><br><span class="line">	skipClean <span class="keyword">bool</span></span><br><span class="line">	<span class="comment">// If true, do not clear the request context after handling the request.</span></span><br><span class="line">	<span class="comment">// This has no effect when go1.7+ is used, since the context is stored</span></span><br><span class="line">	<span class="comment">// on the request itself.</span></span><br><span class="line">	KeepContext <span class="keyword">bool</span></span><br><span class="line">	<span class="comment">// see Router.UseEncodedPath(). This defines a flag for all routes.</span></span><br><span class="line">	useEncodedPath <span class="keyword">bool</span></span><br><span class="line">	<span class="comment">// Slice of middlewares to be called after a match is found</span></span><br><span class="line">	middlewares []middleware</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中三个 <code>flag</code> 只要看注释就知道它们的作用了，不多解释：</p>
<ul>
<li><p>strictSlash</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StrictSlash defines the trailing slash behavior for new routes. The initial</span></span><br><span class="line"><span class="comment">// value is false.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// When true, if the route path is "/path/", accessing "/path" will perform a redirect</span></span><br><span class="line"><span class="comment">// to the former and vice versa. In other words, your application will always</span></span><br><span class="line"><span class="comment">// see the path as specified in the route.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// When false, if the route path is "/path", accessing "/path/" will not match</span></span><br><span class="line"><span class="comment">// this route and vice versa.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Router)</span> <span class="title">StrictSlash</span><span class="params">(value <span class="keyword">bool</span>)</span> *<span class="title">Router</span></span> &#123;</span><br><span class="line">    r.strictSlash = value</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>skipClean</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SkipClean defines the path cleaning behaviour for new routes. The initial</span></span><br><span class="line"><span class="comment">// value is false. Users should be careful about which routes are not cleaned</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// When true, if the route path is "/path//to", it will remain with the double</span></span><br><span class="line"><span class="comment">// slash. This is helpful if you have a route like: /fetch/http://xkcd.com/534/</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// When false, the path will be cleaned, so /fetch/http://xkcd.com/534/ will</span></span><br><span class="line"><span class="comment">// become /fetch/http/xkcd.com/534</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Router)</span> <span class="title">SkipClean</span><span class="params">(value <span class="keyword">bool</span>)</span> *<span class="title">Router</span></span> &#123;</span><br><span class="line">    r.skipClean = value</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>useEncodedPath</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UseEncodedPath tells the router to match the encoded original path</span></span><br><span class="line"><span class="comment">// to the routes.</span></span><br><span class="line"><span class="comment">// For eg. "/path/foo%2Fbar/to" will match the path "/path/&#123;var&#125;/to".</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If not called, the router will match the unencoded path to the routes.</span></span><br><span class="line"><span class="comment">// For eg. "/path/foo%2Fbar/to" will match the path "/path/foo/bar/to"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Router)</span> <span class="title">UseEncodedPath</span><span class="params">()</span> *<span class="title">Router</span></span> &#123;</span><br><span class="line">    r.useEncodedPath = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>先看看它的 <code>HandleFunc</code> ，首先 <code>NewRoute</code> 创建一个 <code>Route</code> ，然后 <code>Path</code> 为 <code>path</code> 添加一个 <code>matcher</code> ，最后 <code>HandlerFunc</code> 为其设置一个 <code>handler</code> ：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HandleFunc registers a new route with a matcher for the URL path.</span></span><br><span class="line"><span class="comment">// See Route.Path() and Route.HandlerFunc().</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Router)</span> <span class="title">HandleFunc</span><span class="params">(path <span class="keyword">string</span>, f <span class="keyword">func</span>(http.ResponseWriter,</span></span></span><br><span class="line"><span class="function"><span class="params">	*http.Request)</span>) *<span class="title">Route</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> r.NewRoute().Path(path).HandlerFunc(f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其次看看 <code>Router</code> 的 <code>ServeHTTP</code> ，先使用上面说的 <code>flag</code> 对 <code>Request</code> 中的 <code>URL</code> 进行预处理，然后使用 <code>Router</code> 的 <code>Match</code> 方法查找 <code>handler</code>。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ServeHTTP dispatches the handler registered in the matched route.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// When there is a match, the route variables can be retrieved calling</span></span><br><span class="line"><span class="comment">// mux.Vars(request).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Router)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> !r.skipClean &#123;</span><br><span class="line">		path := req.URL.Path</span><br><span class="line">		<span class="keyword">if</span> r.useEncodedPath &#123;</span><br><span class="line">			path = req.URL.EscapedPath()</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Clean path to canonical form and redirect.</span></span><br><span class="line">		<span class="keyword">if</span> p := cleanPath(path); p != path &#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Added 3 lines (Philip Schlump) - It was dropping the query string and #whatever from query.</span></span><br><span class="line">			<span class="comment">// This matches with fix in go 1.2 r.c. 4 for same problem.  Go Issue:</span></span><br><span class="line">			<span class="comment">// http://code.google.com/p/go/issues/detail?id=5252</span></span><br><span class="line">			url := *req.URL</span><br><span class="line">			url.Path = p</span><br><span class="line">			p = url.String()</span><br><span class="line"></span><br><span class="line">			w.Header().Set(<span class="string">"Location"</span>, p)</span><br><span class="line">			w.WriteHeader(http.StatusMovedPermanently)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> match RouteMatch</span><br><span class="line">	<span class="keyword">var</span> handler http.Handler</span><br><span class="line">	<span class="keyword">if</span> r.Match(req, &amp;match) &#123;</span><br><span class="line">		handler = match.Handler</span><br><span class="line">		req = setVars(req, match.Vars)</span><br><span class="line">		req = setCurrentRoute(req, match.Route)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> handler == <span class="literal">nil</span> &amp;&amp; match.MatchErr == ErrMethodMismatch &#123;</span><br><span class="line">		handler = methodNotAllowedHandler()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> handler == <span class="literal">nil</span> &#123;</span><br><span class="line">		handler = http.NotFoundHandler()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !r.KeepContext &#123;</span><br><span class="line">		<span class="keyword">defer</span> contextClear(req)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	handler.ServeHTTP(w, req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>再看看 <code>Router</code> 的 <code>Match</code> 方法，遍历 <code>Router</code> 下的所有 <code>route</code> 看看是否匹配：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Match attempts to match the given request against the router's registered routes.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If the request matches a route of this router or one of its subrouters the Route,</span></span><br><span class="line"><span class="comment">// Handler, and Vars fields of the the match argument are filled and this function</span></span><br><span class="line"><span class="comment">// returns true.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If the request does not match any of this router's or its subrouters' routes</span></span><br><span class="line"><span class="comment">// then this function returns false. If available, a reason for the match failure</span></span><br><span class="line"><span class="comment">// will be filled in the match argument's MatchErr field. If the match failure type</span></span><br><span class="line"><span class="comment">// (eg: not found) has a registered handler, the handler is assigned to the Handler</span></span><br><span class="line"><span class="comment">// field of the match argument.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Router)</span> <span class="title">Match</span><span class="params">(req *http.Request, match *RouteMatch)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, route := <span class="keyword">range</span> r.routes &#123;</span><br><span class="line">		<span class="keyword">if</span> route.Match(req, match) &#123;</span><br><span class="line">			<span class="comment">// Build middleware chain if no error was found</span></span><br><span class="line">			<span class="keyword">if</span> match.MatchErr == <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">for</span> i := <span class="built_in">len</span>(r.middlewares) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">					match.Handler = r.middlewares[i].Middleware(match.Handler)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">// 省略</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这里我们还不能看出 <code>Router</code> 是怎么实现如此强大的路由的，因为重点是 Route。</p>
<h3 id="route-go"><a href="#route-go" class="headerlink" title="route.go"></a>route.go</h3><p>照例看看数据结构，有父路由 <code>parent</code> 、处理器 <code>handler</code> 、匹配器表 <code>matchers</code> 、正则表达式 <code>regexp</code> 以及前面提到的三个 <code>flag</code> 等：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Route stores information to match a request and build URLs.</span></span><br><span class="line"><span class="keyword">type</span> Route <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// Parent where the route was registered (a Router).</span></span><br><span class="line">	parent parentRoute</span><br><span class="line">	<span class="comment">// Request handler for the route.</span></span><br><span class="line">	handler http.Handler</span><br><span class="line">	<span class="comment">// List of matchers.</span></span><br><span class="line">	matchers []matcher</span><br><span class="line">	<span class="comment">// Manager for the variables from host and path.</span></span><br><span class="line">	regexp *routeRegexpGroup</span><br><span class="line">	<span class="comment">// If true, when the path pattern is "/path/", accessing "/path" will</span></span><br><span class="line">	<span class="comment">// redirect to the former and vice versa.</span></span><br><span class="line">	strictSlash <span class="keyword">bool</span></span><br><span class="line">	<span class="comment">// If true, when the path pattern is "/path//to", accessing "/path//to"</span></span><br><span class="line">	<span class="comment">// will not redirect</span></span><br><span class="line">	skipClean <span class="keyword">bool</span></span><br><span class="line">	<span class="comment">// If true, "/path/foo%2Fbar/to" will match the path "/path/&#123;var&#125;/to"</span></span><br><span class="line">	useEncodedPath <span class="keyword">bool</span></span><br><span class="line">	<span class="comment">// The scheme used when building URLs.</span></span><br><span class="line">	buildScheme <span class="keyword">string</span></span><br><span class="line">	<span class="comment">// If true, this route never matches: it is only used to build URLs.</span></span><br><span class="line">	buildOnly <span class="keyword">bool</span></span><br><span class="line">	<span class="comment">// The name used to build URLs.</span></span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	<span class="comment">// Error resulted from building a route.</span></span><br><span class="line">	err error</span><br><span class="line"></span><br><span class="line">	buildVarsFunc BuildVarsFunc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>还记得前面创建 <code>Route</code> 后使用的 <code>Path</code> 方法吧，它能为 <code>URL path</code> 添加一个正则表达式匹配器：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Path adds a matcher for the URL path.</span></span><br><span class="line"><span class="comment">// It accepts a template with zero or more URL variables enclosed by &#123;&#125;. The</span></span><br><span class="line"><span class="comment">// template must start with a "/".</span></span><br><span class="line"><span class="comment">// Variables can define an optional regexp pattern to be matched:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// - &#123;name&#125; matches anything until the next slash.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// - &#123;name:pattern&#125; matches the given regexp pattern.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// For example:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//     r := mux.NewRouter()</span></span><br><span class="line"><span class="comment">//     r.Path("/products/").Handler(ProductsHandler)</span></span><br><span class="line"><span class="comment">//     r.Path("/products/&#123;key&#125;").Handler(ProductsHandler)</span></span><br><span class="line"><span class="comment">//     r.Path("/articles/&#123;category&#125;/&#123;id:[0-9]+&#125;").</span></span><br><span class="line"><span class="comment">//       Handler(ArticleHandler)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Variable names must be unique in a given route. They can be retrieved</span></span><br><span class="line"><span class="comment">// calling mux.Vars(request).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Route)</span> <span class="title">Path</span><span class="params">(tpl <span class="keyword">string</span>)</span> *<span class="title">Route</span></span> &#123;</span><br><span class="line">	r.err = r.addRegexpMatcher(tpl, regexpTypePath)</span><br><span class="line">	<span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里就不打算再深入下去探究如何添加的啦，一来作者水平有限，二来大家有不同的实现方式，所以我们就且停留到这一层吧。下面看看 <code>Route</code> 的 <code>Match</code> ：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Match matches the route against the request.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Route)</span> <span class="title">Match</span><span class="params">(req *http.Request, match *RouteMatch)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> r.buildOnly || r.err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> matchErr error</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Match everything.</span></span><br><span class="line">	<span class="keyword">for</span> _, m := <span class="keyword">range</span> r.matchers &#123;</span><br><span class="line">		<span class="keyword">if</span> matched := m.Match(req, match); !matched &#123;</span><br><span class="line">			<span class="keyword">if</span> _, ok := m.(methodMatcher); ok &#123;</span><br><span class="line">				matchErr = ErrMethodMismatch</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			matchErr = <span class="literal">nil</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> matchErr != <span class="literal">nil</span> &#123;</span><br><span class="line">		match.MatchErr = matchErr</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> match.MatchErr == ErrMethodMismatch &#123;</span><br><span class="line">		<span class="comment">// We found a route which matches request method, clear MatchErr</span></span><br><span class="line">		match.MatchErr = <span class="literal">nil</span></span><br><span class="line">		<span class="comment">// Then override the mis-matched handler</span></span><br><span class="line">		match.Handler = r.handler</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Yay, we have a match. Let's collect some info about it.</span></span><br><span class="line">	<span class="keyword">if</span> match.Route == <span class="literal">nil</span> &#123;</span><br><span class="line">		match.Route = r</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> match.Handler == <span class="literal">nil</span> &#123;</span><br><span class="line">		match.Handler = r.handler</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> match.Vars == <span class="literal">nil</span> &#123;</span><br><span class="line">		match.Vars = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Set variables.</span></span><br><span class="line">	<span class="keyword">if</span> r.regexp != <span class="literal">nil</span> &#123;</span><br><span class="line">		r.regexp.setMatch(req, match, r)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>到这里大家可能会疑惑了，<code>// Match everything</code> 指的是什么，其实一个 <code>Route</code> 可以存在多个 <code>matcher</code>，也就是说，你可能设置了一个这样的路由:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r.HandleFunc(<span class="string">"/products"</span>, ProductsHandler).</span><br><span class="line">  Host(<span class="string">"www.example.com"</span>).</span><br><span class="line">  Methods(<span class="string">"GET"</span>).</span><br><span class="line">  Schemes(<span class="string">"http"</span>)</span><br></pre></td></tr></table></figure></p>
<p>那么这个路由就需要满足上述 4 个 <code>matcher</code> 才能够匹配成功，而 <code>Path</code> 和 <code>Host</code> 都是通过添加 <code>routeRegexp</code> 来实现，<code>Methods</code> 和 <code>Schemes</code> 则分别实现了各自的 <code>matcher</code>：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Path and Host add RegexpMatcher</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Route)</span> <span class="title">Path</span><span class="params">(tpl <span class="keyword">string</span>)</span> *<span class="title">Route</span></span> &#123;</span><br><span class="line">	r.err = r.addRegexpMatcher(tpl, regexpTypePath)</span><br><span class="line">	<span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Route)</span> <span class="title">Host</span><span class="params">(tpl <span class="keyword">string</span>)</span> *<span class="title">Route</span></span> &#123;</span><br><span class="line">	r.err = r.addRegexpMatcher(tpl, regexpTypeHost)</span><br><span class="line">	<span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// methodMatcher matches the request against HTTP methods.</span></span><br><span class="line"><span class="keyword">type</span> methodMatcher []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m methodMatcher)</span> <span class="title">Match</span><span class="params">(r *http.Request, match *RouteMatch)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> matchInArray(m, r.Method)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// schemeMatcher matches the request against URL schemes.</span></span><br><span class="line"><span class="keyword">type</span> schemeMatcher []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m schemeMatcher)</span> <span class="title">Match</span><span class="params">(r *http.Request, match *RouteMatch)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> matchInArray(m, r.URL.Scheme)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>你有可能看了我的分析以后更晕了，但是没关系，你只要记住 <code>gorilla/mux</code> 大致是怎么实现路由的就好：</p>
<ol>
<li><p>使用 <code>Router</code> 的 <code>HandleFunc</code> 、<code>Host</code> 、 <code>Methods</code> 、 <code>Schemes</code> 、 <code>Headers</code> 等方法会创建一个路由并且为其添加相应类型 <code>matcher</code>，当然你也可以使用 <code>MatcherFunc</code> 来创建自己的 <code>matcher</code>。如果你想为一个路由添加多个方法，那么你可以这样：</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r.HandleFunc(<span class="string">"/products"</span>, ProductsHandler).</span><br><span class="line">Host(<span class="string">"www.example.com"</span>).</span><br><span class="line">Methods(<span class="string">"GET"</span>).</span><br><span class="line">Schemes(<span class="string">"http)</span></span><br></pre></td></tr></table></figure>
<p> 因为上面说的每个方法都会返回一个刚创建 Route 的指针，这样你就可以使用 Route 的同名方法来添加 matcher 了。</p>
</li>
<li><p><code>gorilla/mux</code> 会查找 <code>Router</code> 下的 <code>Route</code> 列表，找到是否有无匹配的路由，而 <code>Route</code> 会遍历其 <code>matchers</code> 列表来看看是否满足所有的 <code>matchers</code>，只要一个不匹配，则失败。</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://7cthunder.github.io/2018/11/15/服务计算-gorilla-mux-源码解析/" data-id="cjufi5t5p000h7zrpamirwzdx" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Go/">Go</a></li></ul>

    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Go/">Go</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/SWAD/">SWAD</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Go/">Go</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SWAD/">SWAD</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Go/" style="font-size: 10px;">Go</a> <a href="/tags/SWAD/" style="font-size: 20px;">SWAD</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/04/13/SWAD-Homework3/">SWAD | Homework3</a>
          </li>
        
          <li>
            <a href="/2019/04/12/SWAD-Homework2-md/">SWAD | Homework2</a>
          </li>
        
          <li>
            <a href="/2019/03/13/SWAD-Homework1/">SWAD | Homework1</a>
          </li>
        
          <li>
            <a href="/2018/11/15/服务计算-gorilla-mux-源码解析/">服务计算 | gorilla/mux 源码解析</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 Sandra<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>