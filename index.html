<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>7cthunder</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="7cthunder">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="7cthunder">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="7cthunder">
  
    <link rel="alternate" href="/atom.xml" title="7cthunder" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">7cthunder</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">这段代码我已经和小黄鸭商量过了。</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/categories">categories</a>
        
          <a class="main-nav-link" href="/tags">tags</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-SWAD-Homework1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/13/SWAD-Homework1/" class="article-date">
  <time datetime="2019-03-13T15:28:10.000Z" itemprop="datePublished">2019-03-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/SWAD/">SWAD</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/13/SWAD-Homework1/">SWAD | Homework1</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="简答题"><a href="#简答题" class="headerlink" title="简答题"></a>简答题</h2><ul>
<li><p>软件工程的定义</p>
<p>软件工程是研究和应用如何以系统性的、规范化的、可定量的过程化方法去开发和维护软件，以及如何把经过时间考验而证明正确的管理技术和当前能够得到的最好的技术方法结合起来的学科。它涉及到程序设计语言、数据库、软件开发工具、系统平台、标准、设计模式等方面。</p>
</li>
<li><p>解释导致 software crisis 本质原因、表现，述说克服软件危机的方法</p>
<ul>
<li>本质原因：由于软件的大量需求与软件生产力效率之间的矛盾以及软件系统的复杂性与软件开发方法之间的矛盾</li>
<li>表现：<ul>
<li>项目运行超出预算</li>
<li>项目运行超过时间</li>
<li>软件质量低落</li>
<li>软件通常不匹配需求</li>
<li>项目无法管理，且代码难以维护</li>
</ul>
</li>
<li>克服软件危机的方法：<ul>
<li>借鉴其他工程项目中行之有效的原理、概念、技术与方法，特别是吸取人类从事计算机硬件研究和开发的经验教训。在开发软件的过程中做到良好的组织，严格的管理，相互友好的协作。</li>
<li>推广在实践中总结出来的开发软件的成功的技术和方法，并研究更好、更有效的技术和方法，尽快克服在计算机系统早期发展阶段形成的一些错误概念和做法。</li>
<li>根据不同的应用领域，开发更好的软件工具并使用这些工具。将软件开发各个阶段使用的软件工具合成一个整体，形成一个良好的软件开发环境。</li>
</ul>
</li>
</ul>
</li>
<li><p>软件生命周期</p>
<p>在时间维度，对软件项目任务进行划分，又成为软件开发过程。常见有瀑布模型、螺旋模型、敏捷的模型等。</p>
</li>
<li><p>SWEBoK 的 15 个知识域</p>
<ul>
<li><p>Software Requirements 软件需求</p>
<p>软件需求表达了对软件产品的需求和约束，这些需求和约束有助于解决一些实际问题。</p>
</li>
<li><p>Software Design 软件设计</p>
<p>设计是定义系统或组件的体系结构、组件、接口和其他特征的过程、以及该过程的结果。</p>
</li>
<li><p>Software Construction 软件构造</p>
<p>通过详细设计、编码、单元测试、集成测试、调试和验证相结合，对工作软件进行详细的创建。</p>
</li>
<li><p>Software Testing 软件测试</p>
<p>为了验证产品质量并且通过指出缺陷来增进软件质量的活动。</p>
</li>
<li><p>Software Maintenance 软件维护</p>
<p>包括增强现有的功能，使得软件在新的环境中运行以及修正缺陷。</p>
</li>
<li><p>Software Configuration Management 软件配置管理</p>
<p>软件配置管理(Software Configuration Management)： 系统的配置是硬件、固件、软件或它们的组合的功能和/或物理特征。它还可以看作是硬件、固件或软件项目的特定版本的集合，为了服务于特定的目的，将这些硬件、固件和软件项目根据特定的构建过程组合在一起。因此，软件配置管理(SCM)是在不同的时间点识别系统配置的规程，以便系统地控制配置的更改，并在整个软件生命周期中维护配置的完整性和可追溯性。</p>
</li>
<li><p>Software Engineering Management 软件工程管理</p>
<p>包括计划、协调、测量、报告和控制一个项目或程序，确保软件的开发和维护是系统的、规范化的、可定量的。</p>
</li>
<li><p>Software Engineering Process 软件工程过程</p>
<p>软件工程知识领域关注软件生命周期过程的定义，实现，评估，测量，管理和改进。主题包括过程实现和改变(过程基础设施，过程实现和改变模型，和软件过程管理)，过程定义(软件生命周期模型和过程，过程定义，过程适应和自动化过程的符号)，过程评估模型和方法，测量(过程测量，产品测量，技术测量和测量结果质量)和软件过程工具。</p>
</li>
<li><p>Software Engineering Models and Methods 软件工程模型和方法</p>
<p>软件工程技术和管理的原理、原则、方法</p>
</li>
<li><p>Software Quality 软件质量</p>
<p>软件质量是软件生命周期普遍关注的，存在于许多 SWEBOK V3 知识领域中。此外，软件质量知识领域包括软件质量基础(软件工程文化，软件质量特征，软件质量价值和成本和软件质量改进)，软件质量管理过程(软件质量保证，认证和确认，审核和审计)和实际考量(缺陷特征，软件质量测量和软件质量工具)。</p>
</li>
<li><p>Software Engineering Professional Practice 软件工程专业实践</p>
<p>软件工程专业实践关注软件工程师必须具备的知识，技巧和态度，以用一种专业，负责和正直的态度来时间软件工程。软件工程专业实践知识领域涵盖专业性(专业行为，专业协会，软件工程标准，雇佣合同和法律问题)，道德准则，动态小组(团队合作，认知问题复杂性，与利益相关者交互，不确定性和模糊性的处理，多元环境处理)和交流技巧。</p>
</li>
<li><p>Software Engineering Economics 软件工程经济学</p>
<p>软件工程经济学知识领域关注在商业环境中做出决策，以使技术决策和商业目标达成一致。</p>
</li>
<li><p>Computing Foundations 计算基础</p>
<p>计算基础知识领域涵盖对于软件工程实践必须的计算背景的基础主题。涵盖主题包括问题解决技术，抽象，算法和复杂度，编程基础，并行和分布式计算基础，计算机组成，操作系统和网络通信。</p>
</li>
<li><p>Mathematical Foundations</p>
<p>数学基础知识领域涵盖对于软件工程实践必须的数学背景的基础主题。涵盖的主题包括集合，关系和函数，基础命题和谓词逻辑，证明技术，图和树，离散概率，语法和有限状态机，数论。</p>
</li>
<li><p>Engineering Foundations</p>
<p>工程基础知识领域涵盖对于软件工程实践必须的工程背景的基础主题。涵盖的主题包括经验方法和实验技术，统计分析，测量和指标，工程设计，模拟和建模，根本原因分析。</p>
</li>
</ul>
</li>
<li><p>CMMI 的五个级别</p>
<ul>
<li>Level 1 - Initial: 没有可预知的生产过程，缺乏控制和应变能力</li>
<li>Level 2 - Managed: 生产过程为每个项目特制，一般有一定的应变能力。</li>
<li>Level 3 - Defined: 生产过程为组织所定制，并且积极主动。</li>
<li>Level 4 - Quantitatively Managed: 生产过程可测度（预知）且可控。</li>
<li>Level 5 - Optimizing: 生产专注于过程优化。</li>
</ul>
</li>
<li><p>用自己语言简述 SWEBok 或 CMMI</p>
<p>CMMI 全称为能力成熟度模型集成，其本质上就是衡量软件工程的成熟度的五个级别。CMMI可以帮助企业确认当前软件工程处于的级别并且对其进行管理和改进，增强软件的开发和改进能力。其目的就在于使得软件可以在限定时间和预算内完成并且保证其高质量。CMMI分为五个级别，分别是无序、已管理、已定义、量化管理和优化，这五个级别对于软件工程的管理规范一级比一级要严格，是一个渐进性的模型框架，指导了企业对于现有的软件工程进行评估和改进以及开始新的系统性规范化的软件工程。其主要关注点在于：成本效益、明确重过程集中和灵活性。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/13/SWAD-Homework1/" data-id="cjteamcv50001i0rpoovcwz0h" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SWAD/">SWAD</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-服务计算-gorilla-mux-源码解析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/15/服务计算-gorilla-mux-源码解析/" class="article-date">
  <time datetime="2018-11-15T11:29:55.000Z" itemprop="datePublished">2018-11-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Go/">Go</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/15/服务计算-gorilla-mux-源码解析/">服务计算 | gorilla/mux 源码解析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="gorilla-mux-源码解析"><a href="#gorilla-mux-源码解析" class="headerlink" title="gorilla/mux 源码解析"></a>gorilla/mux 源码解析</h1><p>在开始阅读 <code>gorilla/mux</code> 源码之前，不妨让我们看看 <code>Golang</code> 的 <code>net/http</code> 包是怎么实现多路复用的。</p>
<h2 id="net-http"><a href="#net-http" class="headerlink" title="net/http"></a>net/http</h2><p>用一个简单的例子过一下流程:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Hello world, the web server</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"io"</span></span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	helloHandler := <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">		io.WriteString(w, <span class="string">"Hello, world!\n"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	http.HandleFunc(<span class="string">"/hello"</span>, helloHandler)</span><br><span class="line">	log.Fatal(http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先我们调用了 <code>http.HandleFunc</code> 来为 <code>/hello</code> 注册一个 <code>Handler</code>：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.HandleFunc(<span class="string">"/hello"</span>, helloHandler)</span><br></pre></td></tr></table></figure></p>
<p>依次调用下面三个函数/方法，第一个函数表明当我们使用 http.HandleFunc 时默认是注册在 <code>DefaultServeMux</code> 这个默认的多路复用器上；第二个方法中 <code>HandlerFunc(handler)</code> 意思是将 <code>handler</code> 强制转化为 <code>HandlerFunc</code> 因为其实现了 <code>http.Handler</code> 这个接口；第三个方法在 mux.m 中查找是否已为该 <code>URL</code> 注册 <code>handler</code> ，如果有就报错，没有就为其注册：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ServeMux *</span></span><br><span class="line"><span class="keyword">type</span> ServeMux <span class="keyword">struct</span> &#123;</span><br><span class="line">	mu    sync.RWMutex</span><br><span class="line">	m     <span class="keyword">map</span>[<span class="keyword">string</span>]muxEntry</span><br><span class="line">	hosts <span class="keyword">bool</span> <span class="comment">// whether any patterns contain hostnames</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HandleFunc registers the handler function for the given pattern</span></span><br><span class="line"><span class="comment">// in the DefaultServeMux.</span></span><br><span class="line"><span class="comment">// The documentation for ServeMux explains how patterns are matched.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span>)</span> &#123;</span><br><span class="line">	DefaultServeMux.HandleFunc(pattern, handler)</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// HandleFunc registers the handler function for the given pattern.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span>)</span> &#123;</span><br><span class="line">	mux.Handle(pattern, HandlerFunc(handler))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Handle registers the handler for the given pattern.</span></span><br><span class="line"><span class="comment">// If a handler already exists for pattern, Handle panics.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">Handle</span><span class="params">(pattern <span class="keyword">string</span>, handler Handler)</span></span> &#123;</span><br><span class="line">	mux.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> mux.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> pattern == <span class="string">""</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"http: invalid pattern"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> handler == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"http: nil handler"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> _, exist := mux.m[pattern]; exist &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"http: multiple registrations for "</span> + pattern)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> mux.m == <span class="literal">nil</span> &#123;</span><br><span class="line">		mux.m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]muxEntry)</span><br><span class="line">	&#125;</span><br><span class="line">	mux.m[pattern] = muxEntry&#123;h: handler, pattern: pattern&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> pattern[<span class="number">0</span>] != <span class="string">'/'</span> &#123;</span><br><span class="line">		mux.hosts = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来是调用：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure></p>
<p>本文不打算追踪启动 <code>server</code> 的整个过程，不了解或者感兴趣的可以看看 <a href="https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/03.4.md" target="_blank" rel="noopener">Go的http包详解</a> 。我们只挑对我们讲解多路复用感兴趣的部分来讲解，下面看看：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sh serverHandler)</span> <span class="title">ServeHTTP</span><span class="params">(rw ResponseWriter, req *Request)</span></span> &#123;</span><br><span class="line">	handler := sh.srv.Handler</span><br><span class="line">	<span class="keyword">if</span> handler == <span class="literal">nil</span> &#123;</span><br><span class="line">		handler = DefaultServeMux</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> req.RequestURI == <span class="string">"*"</span> &amp;&amp; req.Method == <span class="string">"OPTIONS"</span> &#123;</span><br><span class="line">		handler = globalOptionsHandler&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	handler.ServeHTTP(rw, req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的方法表明当我们在调用 <code>http.ListenAndServe(&quot;:8080&quot;, nil)</code> 没有给 <code>handler</code> 的时候，默认使用 <code>DefaultServeMux</code> ，所以上面的例子调用的是 <code>DefaultServeMux</code> 的 <code>ServeHTTP</code>：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ServeHTTP dispatches the request to the handler whose</span></span><br><span class="line"><span class="comment">// pattern most closely matches the request URL.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">ServeHTTP</span><span class="params">(w ResponseWriter, r *Request)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> r.RequestURI == <span class="string">"*"</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> r.ProtoAtLeast(<span class="number">1</span>, <span class="number">1</span>) &#123;</span><br><span class="line">			w.Header().Set(<span class="string">"Connection"</span>, <span class="string">"close"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		w.WriteHeader(StatusBadRequest)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	h, _ := mux.Handler(r)</span><br><span class="line">	h.ServeHTTP(w, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>让我们看看 <code>DefaultServeMux</code> 是如何查找相应的 <code>handler</code> ，看看 <code>match</code> 的实现，只能简单地实现字符串匹配，用起来不够爽吧？<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Find a handler on a handler map given a path string.</span></span><br><span class="line"><span class="comment">// Most-specific (longest) pattern wins.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">match</span><span class="params">(path <span class="keyword">string</span>)</span> <span class="params">(h Handler, pattern <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// Check for exact match first.</span></span><br><span class="line">	v, ok := mux.m[path]</span><br><span class="line">	<span class="keyword">if</span> ok &#123;</span><br><span class="line">		<span class="keyword">return</span> v.h, v.pattern</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Check for longest valid match.</span></span><br><span class="line">	<span class="keyword">var</span> n = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> mux.m &#123;</span><br><span class="line">		<span class="keyword">if</span> !pathMatch(k, path) &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> h == <span class="literal">nil</span> || <span class="built_in">len</span>(k) &gt; n &#123;</span><br><span class="line">			n = <span class="built_in">len</span>(k)</span><br><span class="line">			h = v.h</span><br><span class="line">			pattern = v.pattern</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当然，复杂也可能意味着性能下降，有兴趣的同学可以看看 <a href="https://github.com/julienschmidt/go-http-routing-benchmark/blob/master/README.md" target="_blank" rel="noopener">Go HTTP Router Benchmark</a> ，毕竟系统是拿来用的，不只是拿来写的。不过作为一个合格的程序员，应该学会用轮子，所以让我们看看 <code>gorilla/mux</code> 是怎么实现路由的吧。</p>
<h2 id="gorilla-mux"><a href="#gorilla-mux" class="headerlink" title="gorilla/mux"></a>gorilla/mux</h2><p>一个简单使用的例子（摘自<a href="https://github.com/gorilla/mux#graceful-shutdown" target="_blank" rel="noopener">官方文档</a>）：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"github.com/gorilla/mux"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">YourHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    w.Write([]<span class="keyword">byte</span>(<span class="string">"Gorilla!\n"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := mux.NewRouter()</span><br><span class="line">    <span class="comment">// Routes consist of a path and a handler function.</span></span><br><span class="line">    r.HandleFunc(<span class="string">"/"</span>, YourHandler)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bind to a port and pass our router in</span></span><br><span class="line">    log.Fatal(http.ListenAndServe(<span class="string">":8000"</span>, r))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一些进阶用法：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以匹配 URL 中的变量</span></span><br><span class="line">r := mux.NewRouter()</span><br><span class="line">r.HandleFunc(<span class="string">"/products/&#123;key&#125;"</span>, ProductHandler)</span><br><span class="line">r.HandleFunc(<span class="string">"/articles/&#123;category&#125;/"</span>, ArticlesCategoryHandler)</span><br><span class="line">r.HandleFunc(<span class="string">"/articles/&#123;category&#125;/&#123;id:[0-9]+&#125;"</span>, ArticleHandler)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用匹配的变量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ArticlesCategoryHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    vars := mux.Vars(r)</span><br><span class="line">    w.WriteHeader(http.StatusOK)</span><br><span class="line">    fmt.Fprintf(w, <span class="string">"Category: %v\n"</span>, vars[<span class="string">"category"</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路径前缀</span></span><br><span class="line">r.PathPrefix(<span class="string">"/products/"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Only matches if domain is "www.example.com".</span></span><br><span class="line">r.Host(<span class="string">"www.example.com"</span>)</span><br><span class="line"><span class="comment">// Matches a dynamic subdomain.</span></span><br><span class="line">r.Host(<span class="string">"&#123;subdomain:[a-z]+&#125;.domain.com"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子路由</span></span><br><span class="line">r := mux.NewRouter()</span><br><span class="line">s := r.Host(<span class="string">"www.example.com"</span>).Subrouter()</span><br></pre></td></tr></table></figure></p>
<p>ok，总之它的功能比官方包要强大的多，下面开始源码分析。</p>
<h3 id="mux-go"><a href="#mux-go" class="headerlink" title="mux.go"></a>mux.go</h3><p>先看看其数据结构，与 <code>http.ServeMux</code> 相比，要多出不少东西，我们主要关注 <code>routes</code> 、<code>parent</code> 以及三个 <code>flag</code>：<code>strictSlash</code>、<code>skipClean</code>、<code>useEncodedPath</code>。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This will send all incoming requests to the router.</span></span><br><span class="line"><span class="keyword">type</span> Router <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// Configurable Handler to be used when no route matches.</span></span><br><span class="line">	NotFoundHandler http.Handler</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Configurable Handler to be used when the request method does not match the route.</span></span><br><span class="line">	MethodNotAllowedHandler http.Handler</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Parent route, if this is a subrouter.</span></span><br><span class="line">	parent parentRoute</span><br><span class="line">	<span class="comment">// Routes to be matched, in order.</span></span><br><span class="line">	routes []*Route</span><br><span class="line">	<span class="comment">// Routes by name for URL building.</span></span><br><span class="line">	namedRoutes <span class="keyword">map</span>[<span class="keyword">string</span>]*Route</span><br><span class="line">	<span class="comment">// See Router.StrictSlash(). This defines the flag for new routes.</span></span><br><span class="line">	strictSlash <span class="keyword">bool</span></span><br><span class="line">	<span class="comment">// See Router.SkipClean(). This defines the flag for new routes.</span></span><br><span class="line">	skipClean <span class="keyword">bool</span></span><br><span class="line">	<span class="comment">// If true, do not clear the request context after handling the request.</span></span><br><span class="line">	<span class="comment">// This has no effect when go1.7+ is used, since the context is stored</span></span><br><span class="line">	<span class="comment">// on the request itself.</span></span><br><span class="line">	KeepContext <span class="keyword">bool</span></span><br><span class="line">	<span class="comment">// see Router.UseEncodedPath(). This defines a flag for all routes.</span></span><br><span class="line">	useEncodedPath <span class="keyword">bool</span></span><br><span class="line">	<span class="comment">// Slice of middlewares to be called after a match is found</span></span><br><span class="line">	middlewares []middleware</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中三个 <code>flag</code> 只要看注释就知道它们的作用了，不多解释：</p>
<ul>
<li><p>strictSlash</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StrictSlash defines the trailing slash behavior for new routes. The initial</span></span><br><span class="line"><span class="comment">// value is false.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// When true, if the route path is "/path/", accessing "/path" will perform a redirect</span></span><br><span class="line"><span class="comment">// to the former and vice versa. In other words, your application will always</span></span><br><span class="line"><span class="comment">// see the path as specified in the route.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// When false, if the route path is "/path", accessing "/path/" will not match</span></span><br><span class="line"><span class="comment">// this route and vice versa.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Router)</span> <span class="title">StrictSlash</span><span class="params">(value <span class="keyword">bool</span>)</span> *<span class="title">Router</span></span> &#123;</span><br><span class="line">    r.strictSlash = value</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>skipClean</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SkipClean defines the path cleaning behaviour for new routes. The initial</span></span><br><span class="line"><span class="comment">// value is false. Users should be careful about which routes are not cleaned</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// When true, if the route path is "/path//to", it will remain with the double</span></span><br><span class="line"><span class="comment">// slash. This is helpful if you have a route like: /fetch/http://xkcd.com/534/</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// When false, the path will be cleaned, so /fetch/http://xkcd.com/534/ will</span></span><br><span class="line"><span class="comment">// become /fetch/http/xkcd.com/534</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Router)</span> <span class="title">SkipClean</span><span class="params">(value <span class="keyword">bool</span>)</span> *<span class="title">Router</span></span> &#123;</span><br><span class="line">    r.skipClean = value</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>useEncodedPath</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UseEncodedPath tells the router to match the encoded original path</span></span><br><span class="line"><span class="comment">// to the routes.</span></span><br><span class="line"><span class="comment">// For eg. "/path/foo%2Fbar/to" will match the path "/path/&#123;var&#125;/to".</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If not called, the router will match the unencoded path to the routes.</span></span><br><span class="line"><span class="comment">// For eg. "/path/foo%2Fbar/to" will match the path "/path/foo/bar/to"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Router)</span> <span class="title">UseEncodedPath</span><span class="params">()</span> *<span class="title">Router</span></span> &#123;</span><br><span class="line">    r.useEncodedPath = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>先看看它的 <code>HandleFunc</code> ，首先 <code>NewRoute</code> 创建一个 <code>Route</code> ，然后 <code>Path</code> 为 <code>path</code> 添加一个 <code>matcher</code> ，最后 <code>HandlerFunc</code> 为其设置一个 <code>handler</code> ：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HandleFunc registers a new route with a matcher for the URL path.</span></span><br><span class="line"><span class="comment">// See Route.Path() and Route.HandlerFunc().</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Router)</span> <span class="title">HandleFunc</span><span class="params">(path <span class="keyword">string</span>, f <span class="keyword">func</span>(http.ResponseWriter,</span></span></span><br><span class="line"><span class="function"><span class="params">	*http.Request)</span>) *<span class="title">Route</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> r.NewRoute().Path(path).HandlerFunc(f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其次看看 <code>Router</code> 的 <code>ServeHTTP</code> ，先使用上面说的 <code>flag</code> 对 <code>Request</code> 中的 <code>URL</code> 进行预处理，然后使用 <code>Router</code> 的 <code>Match</code> 方法查找 <code>handler</code>。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ServeHTTP dispatches the handler registered in the matched route.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// When there is a match, the route variables can be retrieved calling</span></span><br><span class="line"><span class="comment">// mux.Vars(request).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Router)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> !r.skipClean &#123;</span><br><span class="line">		path := req.URL.Path</span><br><span class="line">		<span class="keyword">if</span> r.useEncodedPath &#123;</span><br><span class="line">			path = req.URL.EscapedPath()</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Clean path to canonical form and redirect.</span></span><br><span class="line">		<span class="keyword">if</span> p := cleanPath(path); p != path &#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Added 3 lines (Philip Schlump) - It was dropping the query string and #whatever from query.</span></span><br><span class="line">			<span class="comment">// This matches with fix in go 1.2 r.c. 4 for same problem.  Go Issue:</span></span><br><span class="line">			<span class="comment">// http://code.google.com/p/go/issues/detail?id=5252</span></span><br><span class="line">			url := *req.URL</span><br><span class="line">			url.Path = p</span><br><span class="line">			p = url.String()</span><br><span class="line"></span><br><span class="line">			w.Header().Set(<span class="string">"Location"</span>, p)</span><br><span class="line">			w.WriteHeader(http.StatusMovedPermanently)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> match RouteMatch</span><br><span class="line">	<span class="keyword">var</span> handler http.Handler</span><br><span class="line">	<span class="keyword">if</span> r.Match(req, &amp;match) &#123;</span><br><span class="line">		handler = match.Handler</span><br><span class="line">		req = setVars(req, match.Vars)</span><br><span class="line">		req = setCurrentRoute(req, match.Route)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> handler == <span class="literal">nil</span> &amp;&amp; match.MatchErr == ErrMethodMismatch &#123;</span><br><span class="line">		handler = methodNotAllowedHandler()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> handler == <span class="literal">nil</span> &#123;</span><br><span class="line">		handler = http.NotFoundHandler()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !r.KeepContext &#123;</span><br><span class="line">		<span class="keyword">defer</span> contextClear(req)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	handler.ServeHTTP(w, req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>再看看 <code>Router</code> 的 <code>Match</code> 方法，遍历 <code>Router</code> 下的所有 <code>route</code> 看看是否匹配：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Match attempts to match the given request against the router's registered routes.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If the request matches a route of this router or one of its subrouters the Route,</span></span><br><span class="line"><span class="comment">// Handler, and Vars fields of the the match argument are filled and this function</span></span><br><span class="line"><span class="comment">// returns true.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If the request does not match any of this router's or its subrouters' routes</span></span><br><span class="line"><span class="comment">// then this function returns false. If available, a reason for the match failure</span></span><br><span class="line"><span class="comment">// will be filled in the match argument's MatchErr field. If the match failure type</span></span><br><span class="line"><span class="comment">// (eg: not found) has a registered handler, the handler is assigned to the Handler</span></span><br><span class="line"><span class="comment">// field of the match argument.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Router)</span> <span class="title">Match</span><span class="params">(req *http.Request, match *RouteMatch)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, route := <span class="keyword">range</span> r.routes &#123;</span><br><span class="line">		<span class="keyword">if</span> route.Match(req, match) &#123;</span><br><span class="line">			<span class="comment">// Build middleware chain if no error was found</span></span><br><span class="line">			<span class="keyword">if</span> match.MatchErr == <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">for</span> i := <span class="built_in">len</span>(r.middlewares) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">					match.Handler = r.middlewares[i].Middleware(match.Handler)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">// 省略</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这里我们还不能看出 <code>Router</code> 是怎么实现如此强大的路由的，因为重点是 Route。</p>
<h3 id="route-go"><a href="#route-go" class="headerlink" title="route.go"></a>route.go</h3><p>照例看看数据结构，有父路由 <code>parent</code> 、处理器 <code>handler</code> 、匹配器表 <code>matchers</code> 、正则表达式 <code>regexp</code> 以及前面提到的三个 <code>flag</code> 等：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Route stores information to match a request and build URLs.</span></span><br><span class="line"><span class="keyword">type</span> Route <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// Parent where the route was registered (a Router).</span></span><br><span class="line">	parent parentRoute</span><br><span class="line">	<span class="comment">// Request handler for the route.</span></span><br><span class="line">	handler http.Handler</span><br><span class="line">	<span class="comment">// List of matchers.</span></span><br><span class="line">	matchers []matcher</span><br><span class="line">	<span class="comment">// Manager for the variables from host and path.</span></span><br><span class="line">	regexp *routeRegexpGroup</span><br><span class="line">	<span class="comment">// If true, when the path pattern is "/path/", accessing "/path" will</span></span><br><span class="line">	<span class="comment">// redirect to the former and vice versa.</span></span><br><span class="line">	strictSlash <span class="keyword">bool</span></span><br><span class="line">	<span class="comment">// If true, when the path pattern is "/path//to", accessing "/path//to"</span></span><br><span class="line">	<span class="comment">// will not redirect</span></span><br><span class="line">	skipClean <span class="keyword">bool</span></span><br><span class="line">	<span class="comment">// If true, "/path/foo%2Fbar/to" will match the path "/path/&#123;var&#125;/to"</span></span><br><span class="line">	useEncodedPath <span class="keyword">bool</span></span><br><span class="line">	<span class="comment">// The scheme used when building URLs.</span></span><br><span class="line">	buildScheme <span class="keyword">string</span></span><br><span class="line">	<span class="comment">// If true, this route never matches: it is only used to build URLs.</span></span><br><span class="line">	buildOnly <span class="keyword">bool</span></span><br><span class="line">	<span class="comment">// The name used to build URLs.</span></span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	<span class="comment">// Error resulted from building a route.</span></span><br><span class="line">	err error</span><br><span class="line"></span><br><span class="line">	buildVarsFunc BuildVarsFunc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>还记得前面创建 <code>Route</code> 后使用的 <code>Path</code> 方法吧，它能为 <code>URL path</code> 添加一个正则表达式匹配器：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Path adds a matcher for the URL path.</span></span><br><span class="line"><span class="comment">// It accepts a template with zero or more URL variables enclosed by &#123;&#125;. The</span></span><br><span class="line"><span class="comment">// template must start with a "/".</span></span><br><span class="line"><span class="comment">// Variables can define an optional regexp pattern to be matched:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// - &#123;name&#125; matches anything until the next slash.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// - &#123;name:pattern&#125; matches the given regexp pattern.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// For example:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//     r := mux.NewRouter()</span></span><br><span class="line"><span class="comment">//     r.Path("/products/").Handler(ProductsHandler)</span></span><br><span class="line"><span class="comment">//     r.Path("/products/&#123;key&#125;").Handler(ProductsHandler)</span></span><br><span class="line"><span class="comment">//     r.Path("/articles/&#123;category&#125;/&#123;id:[0-9]+&#125;").</span></span><br><span class="line"><span class="comment">//       Handler(ArticleHandler)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Variable names must be unique in a given route. They can be retrieved</span></span><br><span class="line"><span class="comment">// calling mux.Vars(request).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Route)</span> <span class="title">Path</span><span class="params">(tpl <span class="keyword">string</span>)</span> *<span class="title">Route</span></span> &#123;</span><br><span class="line">	r.err = r.addRegexpMatcher(tpl, regexpTypePath)</span><br><span class="line">	<span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里就不打算再深入下去探究如何添加的啦，一来作者水平有限，二来大家有不同的实现方式，所以我们就且停留到这一层吧。下面看看 <code>Route</code> 的 <code>Match</code> ：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Match matches the route against the request.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Route)</span> <span class="title">Match</span><span class="params">(req *http.Request, match *RouteMatch)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> r.buildOnly || r.err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> matchErr error</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Match everything.</span></span><br><span class="line">	<span class="keyword">for</span> _, m := <span class="keyword">range</span> r.matchers &#123;</span><br><span class="line">		<span class="keyword">if</span> matched := m.Match(req, match); !matched &#123;</span><br><span class="line">			<span class="keyword">if</span> _, ok := m.(methodMatcher); ok &#123;</span><br><span class="line">				matchErr = ErrMethodMismatch</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			matchErr = <span class="literal">nil</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> matchErr != <span class="literal">nil</span> &#123;</span><br><span class="line">		match.MatchErr = matchErr</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> match.MatchErr == ErrMethodMismatch &#123;</span><br><span class="line">		<span class="comment">// We found a route which matches request method, clear MatchErr</span></span><br><span class="line">		match.MatchErr = <span class="literal">nil</span></span><br><span class="line">		<span class="comment">// Then override the mis-matched handler</span></span><br><span class="line">		match.Handler = r.handler</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Yay, we have a match. Let's collect some info about it.</span></span><br><span class="line">	<span class="keyword">if</span> match.Route == <span class="literal">nil</span> &#123;</span><br><span class="line">		match.Route = r</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> match.Handler == <span class="literal">nil</span> &#123;</span><br><span class="line">		match.Handler = r.handler</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> match.Vars == <span class="literal">nil</span> &#123;</span><br><span class="line">		match.Vars = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Set variables.</span></span><br><span class="line">	<span class="keyword">if</span> r.regexp != <span class="literal">nil</span> &#123;</span><br><span class="line">		r.regexp.setMatch(req, match, r)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>到这里大家可能会疑惑了，<code>// Match everything</code> 指的是什么，其实一个 <code>Route</code> 可以存在多个 <code>matcher</code>，也就是说，你可能设置了一个这样的路由:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r.HandleFunc(<span class="string">"/products"</span>, ProductsHandler).</span><br><span class="line">  Host(<span class="string">"www.example.com"</span>).</span><br><span class="line">  Methods(<span class="string">"GET"</span>).</span><br><span class="line">  Schemes(<span class="string">"http"</span>)</span><br></pre></td></tr></table></figure></p>
<p>那么这个路由就需要满足上述 4 个 <code>matcher</code> 才能够匹配成功，而 <code>Path</code> 和 <code>Host</code> 都是通过添加 <code>routeRegexp</code> 来实现，<code>Methods</code> 和 <code>Schemes</code> 则分别实现了各自的 <code>matcher</code>：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Path and Host add RegexpMatcher</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Route)</span> <span class="title">Path</span><span class="params">(tpl <span class="keyword">string</span>)</span> *<span class="title">Route</span></span> &#123;</span><br><span class="line">	r.err = r.addRegexpMatcher(tpl, regexpTypePath)</span><br><span class="line">	<span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Route)</span> <span class="title">Host</span><span class="params">(tpl <span class="keyword">string</span>)</span> *<span class="title">Route</span></span> &#123;</span><br><span class="line">	r.err = r.addRegexpMatcher(tpl, regexpTypeHost)</span><br><span class="line">	<span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// methodMatcher matches the request against HTTP methods.</span></span><br><span class="line"><span class="keyword">type</span> methodMatcher []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m methodMatcher)</span> <span class="title">Match</span><span class="params">(r *http.Request, match *RouteMatch)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> matchInArray(m, r.Method)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// schemeMatcher matches the request against URL schemes.</span></span><br><span class="line"><span class="keyword">type</span> schemeMatcher []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m schemeMatcher)</span> <span class="title">Match</span><span class="params">(r *http.Request, match *RouteMatch)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> matchInArray(m, r.URL.Scheme)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>你有可能看了我的分析以后更晕了，但是没关系，你只要记住 <code>gorilla/mux</code> 大致是怎么实现路由的就好：</p>
<ol>
<li><p>使用 <code>Router</code> 的 <code>HandleFunc</code> 、<code>Host</code> 、 <code>Methods</code> 、 <code>Schemes</code> 、 <code>Headers</code> 等方法会创建一个路由并且为其添加相应类型 <code>matcher</code>，当然你也可以使用 <code>MatcherFunc</code> 来创建自己的 <code>matcher</code>。如果你想为一个路由添加多个方法，那么你可以这样：</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r.HandleFunc(<span class="string">"/products"</span>, ProductsHandler).</span><br><span class="line">Host(<span class="string">"www.example.com"</span>).</span><br><span class="line">Methods(<span class="string">"GET"</span>).</span><br><span class="line">Schemes(<span class="string">"http)</span></span><br></pre></td></tr></table></figure>
<p> 因为上面说的每个方法都会返回一个刚创建 Route 的指针，这样你就可以使用 Route 的同名方法来添加 matcher 了。</p>
</li>
<li><p><code>gorilla/mux</code> 会查找 <code>Router</code> 下的 <code>Route</code> 列表，找到是否有无匹配的路由，而 <code>Route</code> 会遍历其 <code>matchers</code> 列表来看看是否满足所有的 <code>matchers</code>，只要一个不匹配，则失败。</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/15/服务计算-gorilla-mux-源码解析/" data-id="cjteamcvr0007i0rpb4vrewr3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Go/">Go</a></li></ul>

    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Go/">Go</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/SWAD/">SWAD</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Go/">Go</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SWAD/">SWAD</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Go/" style="font-size: 10px;">Go</a> <a href="/tags/SWAD/" style="font-size: 10px;">SWAD</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/03/13/SWAD-Homework1/">SWAD | Homework1</a>
          </li>
        
          <li>
            <a href="/2018/11/15/服务计算-gorilla-mux-源码解析/">服务计算 | gorilla/mux 源码解析</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 Sandra<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/categories" class="mobile-nav-link">categories</a>
  
    <a href="/tags" class="mobile-nav-link">tags</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>