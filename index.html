<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>7cthunder</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="7cthunder">
<meta property="og:url" content="https://7cthunder.github.io/index.html">
<meta property="og:site_name" content="7cthunder">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="7cthunder">
  
    <link rel="alternate" href="/atom.xml" title="7cthunder" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">7cthunder</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">这段代码我已经和小黄鸭商量过了。</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://7cthunder.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Swagger-Mock" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/23/Swagger-Mock/" class="article-date">
  <time datetime="2019-06-23T15:49:33.000Z" itemprop="datePublished">2019-06-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/RESTful/">RESTful</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/23/Swagger-Mock/">Swagger &amp; Mock</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>之前在开发数据库课程项目的时候，作为 Leader，一直在想怎么解决前后端开发同时进行的问题，这学期知道了Swagger 这个东西，有了它我们的开发流程是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- 协商API</span><br><span class="line">    - 前端开发</span><br><span class="line">        - 编写前端页面</span><br><span class="line">        - 通过 Mock Server 充当真服务端 </span><br><span class="line">    - 服务端开发</span><br><span class="line">        - ...</span><br></pre></td></tr></table></figure></p>
<p>也就是说，前端在开发过程中，不需要等待服务端的小火鸡写完接口再进行测试，通过 Mock Server 即可返回想要的 Response 进行各种测试。</p>
<h2 id="Swagger"><a href="#Swagger" class="headerlink" title="Swagger"></a>Swagger</h2><p>何为 Swagger，照我的理解，就是一个写API文档的框架，之前写项目基本都是手撸API文档，然后从零编写服务端和客户端代码，而有了它，我们只需要编写一个 yaml 文件，它就可以自动帮我们生成客户端 API 调用代码、服务端大致框架以及一个好用的API文档。</p>
<p>多说无益，上手玩玩才知道多棒！传送门：<a href="http://editor.swagger.io/" target="_blank" rel="noopener">Swagger Editer</a></p>
<h3 id="怎么用？"><a href="#怎么用？" class="headerlink" title="怎么用？"></a>怎么用？</h3><p>看看下面这个小例子吧（主要看有注释的那几行即可）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">paths:</span><br><span class="line">  /pet:                                     # api path</span><br><span class="line">    post:                                   # api method</span><br><span class="line">      tags:</span><br><span class="line">      - &quot;pet&quot;</span><br><span class="line">      summary: &quot;Add a new pet to the store&quot;</span><br><span class="line">      description: &quot;&quot;</span><br><span class="line">      operationId: &quot;addPet&quot;                 # 这个名字会成为上面所说生成代码的调用接口</span><br><span class="line">      consumes:                             # Request 数据格式为：</span><br><span class="line">      - &quot;application/json&quot;                  # - json</span><br><span class="line">      - &quot;application/xml&quot;                   # - xml</span><br><span class="line">      produces:                             # Response 数据格式为：</span><br><span class="line">      - &quot;application/xml&quot;                   # - xml</span><br><span class="line">      - &quot;application/json&quot;                  # - json</span><br><span class="line">      parameters:                           # Request 参数</span><br><span class="line">      - in: &quot;body&quot;                          # 参数位于 body 中 (因为 Method 为 POST)</span><br><span class="line">        name: &quot;body&quot;</span><br><span class="line">        description: &quot;Pet object that needs to be added to the store&quot;</span><br><span class="line">        required: true                      # Request 必须有此参数</span><br><span class="line">        schema:</span><br><span class="line">          $ref: &quot;#/definitions/Pet&quot;         # 参数的样式，这里为 Pet</span><br><span class="line">      responses:                            # Response 返回样例</span><br><span class="line">        405:                                # Response status</span><br><span class="line">          description: &quot;Invalid input&quot;</span><br></pre></td></tr></table></figure></p>
<p>上面编写的 yaml 文件就帮我们描述了 POST /pet 这个添加宠物的接口啦！</p>
<h3 id="生成代码"><a href="#生成代码" class="headerlink" title="生成代码"></a>生成代码</h3><p>我们可以分别生成 Server 和 Client 代码，这里分别选择 go-server 和 JavaScript</p>
<p>先看看前端 JavaScript 代码，实际上，如果让我们手撸一个这样的接口，我们并不会写得这么健全，如果我们需要发送一个POST请求，那么我们可能只会写 body 这部分的参数，而不会像下面所示代码那样，面面俱到，也许是有些许冗余了，但是机器生成的代码，还要什么自行车呢？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Add a new pet to the store</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param &#123;module:model/Pet&#125; body Pet object that needs to be added to the store</span></span><br><span class="line"><span class="comment"> * @param &#123;module:api/PetApi~addPetCallback&#125; callback The callback function, accepting three arguments: error, data, response</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">this</span>.addPet = <span class="function"><span class="keyword">function</span>(<span class="params">body, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> postBody = body;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// verify the required parameter 'body' is set</span></span><br><span class="line">  <span class="keyword">if</span> (body === <span class="literal">undefined</span> || body === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Missing the required parameter 'body' when calling addPet"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> pathParams = &#123;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">var</span> queryParams = &#123;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">var</span> collectionQueryParams = &#123;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">var</span> headerParams = &#123;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">var</span> formParams = &#123;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> authNames = [<span class="string">'petstore_auth'</span>];</span><br><span class="line">  <span class="keyword">var</span> contentTypes = [<span class="string">'application/json'</span>, <span class="string">'application/xml'</span>];</span><br><span class="line">  <span class="keyword">var</span> accepts = [<span class="string">'application/xml'</span>, <span class="string">'application/json'</span>];</span><br><span class="line">  <span class="keyword">var</span> returnType = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.apiClient.callApi(</span><br><span class="line">    <span class="string">'/pet'</span>, <span class="string">'POST'</span>,</span><br><span class="line">    pathParams, queryParams, collectionQueryParams, headerParams, formParams, postBody,</span><br><span class="line">    authNames, contentTypes, accepts, returnType, callback</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>再看看 go-server 代码，其只是一个简单的模板，帮我们写好了 Response 的头，以及帮我们定义了 Pet 这个结构体，需要注意这个需要我们在 yaml 中定义。服务端需要做的，就是搞搞数据库，填填逻辑代码，有了这么一个框架，工作量真的少了！</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pet_api.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddPet</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    w.Header().Set(<span class="string">"Content-Type"</span>, <span class="string">"application/json; charset=UTF-8"</span>)</span><br><span class="line">    w.WriteHeader(http.StatusOK)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pet.go</span></span><br><span class="line"><span class="keyword">type</span> Pet <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">    Id <span class="keyword">int64</span> <span class="string">`json:"id,omitempty"`</span></span><br><span class="line"></span><br><span class="line">    Category *Category <span class="string">`json:"category,omitempty"`</span></span><br><span class="line"></span><br><span class="line">    Name <span class="keyword">string</span> <span class="string">`json:"name"`</span></span><br><span class="line"></span><br><span class="line">    PhotoUrls []<span class="keyword">string</span> <span class="string">`json:"photoUrls"`</span></span><br><span class="line"></span><br><span class="line">    Tags []Tag <span class="string">`json:"tags,omitempty"`</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// pet status in the store</span></span><br><span class="line">    Status <span class="keyword">string</span> <span class="string">`json:"status,omitempty"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Mock"><a href="#Mock" class="headerlink" title="Mock"></a>Mock</h2><p>mock 是在测试过程中，对于一些不容易构造/获取的对象，创建一个mock对象来模拟对象的行为，这里我们不深究，我们选 Mockjs 来玩玩看。</p>
<p>Mock.js 是一款模拟数据生成器，旨在帮助前端工程师独立于后端进行开发，帮助编写单元测试。提供了以下模拟功能：</p>
<ul>
<li>根据数据模板生成模拟数据</li>
<li>模拟 Ajax 请求，生成并返回模拟数据</li>
<li>基于 HTML 模板生成模拟数据</li>
</ul>
<p>直接 <a href="http://mockjs.com/examples.html" target="_blank" rel="noopener">传送</a>，打开控制台就可以照着示例玩耍了：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例如我想创建一个博客列表，每个条目包含id、评分</span></span><br><span class="line">Mock.mock(&#123;</span><br><span class="line">  <span class="string">'posts|5'</span>: [&#123;</span><br><span class="line">    <span class="string">'id|+1'</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">'stars|1-10'</span>: <span class="string">'*'</span></span><br><span class="line">  &#125;]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 下面为上述代码所生成</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"posts"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"id"</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="string">"stars"</span>: <span class="string">"*"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"id"</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="string">"stars"</span>: <span class="string">"*"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"id"</span>: <span class="number">3</span>,</span><br><span class="line">      <span class="string">"stars"</span>: <span class="string">"**"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"id"</span>: <span class="number">4</span>,</span><br><span class="line">      <span class="string">"stars"</span>: <span class="string">"*********"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"id"</span>: <span class="number">5</span>,</span><br><span class="line">      <span class="string">"stars"</span>: <span class="string">"*"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Swagger-Mock"><a href="#Swagger-Mock" class="headerlink" title="Swagger-Mock"></a>Swagger-Mock</h2><p>当两者结合起来的威力有多大呢，试想一下，一个可以帮你搭建好服务端框架，一个可以帮你任意生成数据，那么合起来，好像就能弄出一个能 work 的 Server 了不是吗！</p>
<h3 id="swagger-node"><a href="#swagger-node" class="headerlink" title="swagger-node"></a>swagger-node</h3><p>作为一个前端开发人员，node 当然是最亲的啦！swagger支持多种语言，所以我们选择 <a href="https://github.com/swagger-api/swagger-node" target="_blank" rel="noopener">swagger-node</a> 作为伪服务端不是很棒吗。</p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g swagger</span><br></pre></td></tr></table></figure>
<h4 id="创建一个新项目"><a href="#创建一个新项目" class="headerlink" title="创建一个新项目"></a>创建一个新项目</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swagger project create hello-world</span><br></pre></td></tr></table></figure>
<p>看看项目的结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── README.md</span><br><span class="line">├── api</span><br><span class="line">│   ├── assets</span><br><span class="line">│   ├── controllers</span><br><span class="line">│   ├── helpers</span><br><span class="line">│   ├── mocks</span><br><span class="line">│   └── swagger</span><br><span class="line">├── app.js</span><br><span class="line">├── config</span><br><span class="line">│   ├── README.md</span><br><span class="line">│   └── default.yaml</span><br><span class="line">├── package-lock.json</span><br><span class="line">├── package.json</span><br><span class="line">└── test</span><br><span class="line">    └── api</span><br><span class="line"></span><br><span class="line">9 directories, 6 files</span><br></pre></td></tr></table></figure></p>
<h4 id="编辑你的API文档"><a href="#编辑你的API文档" class="headerlink" title="编辑你的API文档"></a>编辑你的API文档</h4><p>这里与前面说的编写 yaml 基本一致，所编辑的 yaml 文件就在 ./api/swagger 中<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swagger project edit</span><br></pre></td></tr></table></figure></p>
<p>不过你需要干一件事，就是给你的 swagger-node 标记一下 controller 所在位置，即：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">paths:</span></span><br><span class="line">  <span class="string">/hello:</span></span><br><span class="line"><span class="attr">      x-swagger-router-controller:</span> <span class="string">hello_world</span>  <span class="comment"># 处理/hello的controller在hello_world.js</span></span><br></pre></td></tr></table></figure></p>
<p>然后再看看 controller：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./api/controllers/hello_world.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 记住要将接口暴露出去 */</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123; hello &#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Functions in a127 controllers used for operations should take two parameters:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Param 1: a handle to the request object</span></span><br><span class="line"><span class="comment">  Param 2: a handle to the response object</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// variables defined in the Swagger document can be referenced using req.swagger.params.&#123;parameter_name&#125;</span></span><br><span class="line">  <span class="keyword">var</span> name = req.swagger.params.name.value || <span class="string">'stranger'</span>;</span><br><span class="line">  <span class="keyword">var</span> hello = util.format(<span class="string">'Hello, %s!'</span>, name);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// this sends back a JSON response which is a single string</span></span><br><span class="line">  res.json(hello);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果你还在手撸 API 文档，不如玩玩 Swagger 啦！</p>
<p>如果你还在从零构建服务端代码，不如让 Swagger 帮帮你啦！</p>
<p>如果你还在等服务端的小火鸡完成API开发，不如自己搭建一个 Swagger-Mock-Server 啦！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://7cthunder.github.io/2019/06/23/Swagger-Mock/" data-id="cjx958t8g000lpsrpuzh7kf3f" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Mock/">Mock</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Swagger/">Swagger</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-SWAD-Homework4" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/22/SWAD-Homework4/" class="article-date">
  <time datetime="2019-05-22T07:16:29.000Z" itemprop="datePublished">2019-05-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/SWAD/">SWAD</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/22/SWAD-Homework4/">SWAD | Homework4</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="简答题"><a href="#简答题" class="headerlink" title="简答题"></a>简答题</h2><ul>
<li><strong>用例的概念</strong><ul>
<li>用例是描述一个参与者使用一个系统来实现一个目标的成功或失败场景的集合</li>
</ul>
</li>
<li><strong>用例和场景的关系？什么是主场景或 happy path？</strong><ul>
<li>场景就是参与者和系统的交互过程，由若干行为和会话组成的特定序列构成，也被称为用例的实例。</li>
<li>用例事实上就是一系列场景的集合，例如：主场景，正零路径或者是其他备选流</li>
<li>主场景就是最常用的一个业务场景，反映的是用户最为基本的目的，简单的说就是这个系统所实现的基本业务</li>
</ul>
</li>
<li><strong>用例有哪些形式？</strong><ul>
<li>摘要 (Brief)：一段总结，通常是主要的成功场景的建立，只需要几分钟的时间</li>
<li>简便格式 (Casual)：不是很正式的形式，并且包括了不同的场景</li>
<li>详述 (Fully)：完整的场景建立，完整的步骤以及用例的细节，以及一些可能发生的情况的应对以及如何确保一个成功的场景</li>
</ul>
</li>
<li><strong>对于复杂业务，为什么编制完整用例非常难？</strong><ul>
<li>因为复杂业务的子用例非常多，流程复杂，且需要处理的场景很多，很难考虑完全所有子用例和场景，绘制的用例图繁杂，容易出错</li>
</ul>
</li>
<li><strong>什么是用例图？</strong><ul>
<li>用例图是表示系统上下文的一张图片，它显示了系统的边界，展示了与系统交互的外部对象，描述了系统的使用方法</li>
</ul>
</li>
<li><strong>用例图的基本符号与元素？</strong><ul>
<li>参与者 (Actor)：表示一个系统用户，包括与应用程序进行交互的用户、组织或外部系统</li>
<li>用例 (Use Case)：表示一个用例，通常用作对系统提供的功能、服务的一种描述</li>
<li>包含关系 (Includes)</li>
<li>扩展关系 (Extends)</li>
<li>关联关系 (Association)</li>
</ul>
</li>
<li><strong>用例图的画法与步骤：</strong><ul>
<li>确定系统边界</li>
<li>识别 Actors<ul>
<li>识别使用系统的主要参与者 (primary actors) / 角色(roles)<ul>
<li>使用用例图 actor符号表示，通常放在系统的左边</li>
<li>企业应用可以通过企业组织架构，业务角色与职责识别</li>
<li>互联网应用则必须通过市场分析，确定受众范围</li>
<li><strong>千万不要用“用户”代表系统使用者，以避免过于通用导致缺乏用户体验</strong>。例如，你的系统服务对象是程序员，但你必须明白 c/c++ 程序员、java 程序员、 PHP 程序员之间的相同与不同</li>
</ul>
</li>
<li>识别系统依赖的外部系统<ul>
<li>使用用例图 Neighboursystem框 表示用例依赖的外部系统、服务、设备，并使用构造型（Stereotype）识别<ul>
<li>&lt;<system>&gt; 例如：Account System（财务系统），教务系统</system></li>
<li>&lt;<service>&gt; 例如：第三方身份认证、地理信息服务、短信服务等第三方在线服务</service></li>
<li>&lt;<device>&gt; 或 &lt;<sensor>&gt; 例如：GPS 等等</sensor></device></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>识别用例 (服务)<ul>
<li>识别用户级别用例（user goal level）<ul>
<li>以主要参与者目标驱动</li>
<li>收集主要参与者的业务事件</li>
<li>必须满足以下准则<ul>
<li>boss test</li>
<li>EBP test</li>
<li>Size Test</li>
</ul>
</li>
<li>manage 用例。特指管理一些事物的 CRUD 操作，例如管理文件、管理用户等</li>
</ul>
</li>
<li>识别子功能级别的用例（sub function level）<ul>
<li>子用例特征<ul>
<li>业务复用。例如：现金支付</li>
<li>复杂业务分解。将业务分解为若干步，便于交互设计与迭代实现</li>
<li>强调技术或业务创新。例如：“识别人脸”，尽管从用户角度是单步操作，但背后涉及技术解决方案是比较复杂的</li>
</ul>
</li>
<li>正确使用用例与子用例之间的关系<ul>
<li>&lt;<include>&gt; 表示子用例是父用例的一部分，通常强调离开这个特性，父用例无法达成目标或失去意义！</include></li>
<li>&lt;<extend>&gt; 表示子用例是父用例的可选场景或技术特征。</extend></li>
<li>&lt;<include>&gt; <strong>箭头指向子用例</strong>；&lt;<extend>&gt; <strong>箭头指向父用例</strong>。箭头表示的依赖关系！</extend></include></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>建立 Actor 和 Use Cases 之间的关联<ul>
<li>请使用 <strong>无方向连线</strong>，表示两间之间是双向交互的协议</li>
</ul>
</li>
</ul>
</li>
<li><strong>用例图给利益相关人与开发者的价值有哪些？</strong><ul>
<li>用例图对于利益相关者来说，他们可以非常直观的了解到自己所要实现的功能是否被很好的体现，开发者是否理解了自己的需求；而对于开发者来说，这不仅是向客户传递自己对需求的理解，也是方便开发者进行系统设计和开发</li>
</ul>
</li>
</ul>
<h2 id="建模练习题（用例模型）"><a href="#建模练习题（用例模型）" class="headerlink" title="建模练习题（用例模型）"></a>建模练习题（用例模型）</h2><p><img src="https://github.com/7cthunder/Blog/raw/master/source/assets/Ctrip-UseCase.png" alt="Ctrip Use Case"></p>
<ul>
<li><p><strong>然后，回答下列问题</strong></p>
<ul>
<li><p><strong>为什么相似系统的用例图是相似的？</strong></p>
<ul>
<li>因为相似系统提供的服务是相似或相同的，面对的用户和用例是相似的，而用例之间的关系是由服务确定的，也是相似的，即使有特色的扩展服务，也是在基本业务上的扩展，都是为了满足相同的需求而提出的，所以最终相似系统的用例图是相似的</li>
</ul>
</li>
<li><p><strong>如果是定旅馆业务，请对比 Asg_RH 用例图，简述如何利用不同时代、不同地区产品的用例图，展现、突出创新业务和技术</strong></p>
<ul>
<li>在现在，可以使用大数据的方法分析每个用户对旅馆类型、价格、位置等的偏好，给每个用户推荐最适合他们的旅馆</li>
<li>对于不同地区的旅馆，可以结合当地特色，在用户选择时为用户介绍，帮助用户做出最佳的选择</li>
</ul>
</li>
<li><p><strong>如何利用用例图定位创新思路（业务创新、或技术创新、或商业模式创新）在系统中的作用</strong></p>
<ul>
<li>在用例图中对创新用例使用某种颜色进行高亮标记，可以很方便地让需求方、开发人员快速了解该系统的创新功能以及该模块相关依赖和输入输出结果</li>
</ul>
</li>
<li><p><strong>请使用 SCRUM 方法，选择一个用例图，编制某定旅馆开发的需求（backlog）开发计划表</strong></p>
</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">ID</th>
<th style="text-align:left">Title</th>
<th style="text-align:center">Est</th>
<th style="text-align:center">Imp</th>
<th style="text-align:center">Demo</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:left">登录</td>
<td style="text-align:center">2</td>
<td style="text-align:center">20</td>
<td style="text-align:center">官方、微信、阿里账号登录</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:left">预定酒店</td>
<td style="text-align:center">5</td>
<td style="text-align:center">30</td>
<td style="text-align:center">搜索酒店、管理订单</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:left">搜索酒店</td>
<td style="text-align:center">2</td>
<td style="text-align:center">40</td>
<td style="text-align:center">多种方式搜索酒店</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:left">城市搜索</td>
<td style="text-align:center">2</td>
<td style="text-align:center">30</td>
<td style="text-align:center">按城市搜索</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:left">地图搜索</td>
<td style="text-align:center">10</td>
<td style="text-align:center">20</td>
<td style="text-align:center">调用第三方地图API来按地图搜索</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:left">标志物搜索</td>
<td style="text-align:center">5</td>
<td style="text-align:center">10</td>
<td style="text-align:center">按标志物来搜索</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:left">订单管理</td>
<td style="text-align:center">3</td>
<td style="text-align:center">30</td>
<td style="text-align:center">添加、删除、修改、查询订单</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:left">支付</td>
<td style="text-align:center">3</td>
<td style="text-align:center">40</td>
<td style="text-align:center">使用银行卡、微信、支付宝支付</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>根据任务4，给出项目用例点的估算</strong></li>
</ul>
<table>
<thead>
<tr>
<th>用例</th>
<th style="text-align:center"># 事务</th>
<th style="text-align:center"># 计算</th>
<th>原因</th>
<th style="text-align:center">UC 权重</th>
</tr>
</thead>
<tbody>
<tr>
<td>登录</td>
<td style="text-align:center">3</td>
<td style="text-align:center">2</td>
<td></td>
<td style="text-align:center">简单</td>
</tr>
<tr>
<td>预定酒店</td>
<td style="text-align:center">8</td>
<td style="text-align:center">8</td>
<td></td>
<td style="text-align:center">复杂性</td>
</tr>
<tr>
<td>搜索酒店</td>
<td style="text-align:center">4</td>
<td style="text-align:center">3</td>
<td></td>
<td style="text-align:center">复杂性</td>
</tr>
<tr>
<td>城市搜索</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td></td>
<td style="text-align:center">简单</td>
</tr>
<tr>
<td>地图搜索</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td></td>
<td style="text-align:center">简单</td>
</tr>
<tr>
<td>标志物搜索</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td></td>
<td style="text-align:center">简单</td>
</tr>
<tr>
<td>订单管理</td>
<td style="text-align:center">4</td>
<td style="text-align:center">4</td>
<td></td>
<td style="text-align:center">平均</td>
</tr>
<tr>
<td>支付</td>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
<td></td>
<td style="text-align:center">平均</td>
</tr>
</tbody>
</table>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://7cthunder.github.io/2019/05/22/SWAD-Homework4/" data-id="cjx958t830008psrpeo3nw3zf" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SWAD/">SWAD</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-SWAD-Homework3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/13/SWAD-Homework3/" class="article-date">
  <time datetime="2019-04-13T09:16:27.000Z" itemprop="datePublished">2019-04-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/SWAD/">SWAD</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/13/SWAD-Homework3/">SWAD | Homework3</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="简述瀑布模型、增量模型、螺旋模型（含原型方法），并分析优缺点"><a href="#简述瀑布模型、增量模型、螺旋模型（含原型方法），并分析优缺点" class="headerlink" title="简述瀑布模型、增量模型、螺旋模型（含原型方法），并分析优缺点"></a>简述瀑布模型、增量模型、螺旋模型（含原型方法），并分析优缺点</h2><blockquote>
<p>从项目特点、风险特征、人力资源利用角度思考</p>
<p>(以下部分为个人观点)</p>
</blockquote>
<h3 id="瀑布模型"><a href="#瀑布模型" class="headerlink" title="瀑布模型"></a>瀑布模型</h3><p>瀑布模型将软件生命周期划分为制定计划、分析、设计、编码、测试、运行维护等阶段，其规定了上述阶段必须自上而下，像瀑布一样。本阶段活动的工作对象来自于上一项活动的输出，这些输出一般是代表本阶段活动结束的里程碑式的文档，本阶段活动产出相关的软件工件，作为下一阶段活动的输入。改进的瀑布模型可以在下游阶段发现缺陷后返回上一个阶段，或者如果下游阶段认为不足则返回到设计阶段。</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol>
<li>降低软件开发的复杂程度，提高软件开发过程的透明性，提高软件开发过程的可管理性，可适用于大型项目</li>
<li>不同人员可以只根据上一阶段的文档，进行本阶段的工作，有利于人员的组织和管理  </li>
</ol>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li>缺乏灵活性，尤其无法解决软件需求不明确或不准确的问题</li>
<li>风险控制能力较弱</li>
<li>管理人员如果仅仅以文档的完成情况来评估项目完成进度，往<br>往会产生错误的结论</li>
</ol>
<h3 id="增量模型"><a href="#增量模型" class="headerlink" title="增量模型"></a>增量模型</h3><p>增量模型采用随着日程时间的进展而交错的线性序列，每一个线性序列产生软件的一个可发布的“增量”。其首先对系统最核心或最清晰的需求进行分析、设计、实现、测试并集成到系统中，再按优先级逐步实现后续需求。增量模型强调每一个增量均发布一个可操作的产品。</p>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ol>
<li>提高系统可靠性</li>
<li>降低系统失败风险</li>
<li>通过同一个团队的工作来交付每个增量，保持所有团队处于工作状态，减少了员工的工作量，工作分布曲线通过项目中的时间阶段被拉平。</li>
</ol>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li>建立初始模型时，作为增量基础的基本业务服务的确定有一定难度</li>
<li>增量粒度难以选择</li>
</ol>
<h3 id="螺旋模型"><a href="#螺旋模型" class="headerlink" title="螺旋模型"></a>螺旋模型</h3><p>螺旋模型结合了瀑布模型和快速原型方法，将瀑布模型的多个阶段转化到多个迭代过程中，以降低项目的风险。螺旋模型最大的特点在于引入了其他模型不具有的风险分析，使软件在无法排除重大风险时有机会停止，以减小损失。同时，在每个迭代阶段构建原型是螺旋模型用以减少风险的途径。螺旋模型的每一次迭代都包含了以下六个步骤：</p>
<ul>
<li>决定目标、替代方案和约束条件</li>
<li>识别和解决项目的风险</li>
<li>评估技术方案和替代方案</li>
<li>开发本次迭代的交付物，并验证迭代产出的正确性</li>
<li>计划下一次迭代</li>
<li>提交下一次迭代的步骤和方案</li>
</ul>
<h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><ol>
<li>整体过程具备很高的灵活性，在开发过程的任何阶段自由应对变化</li>
<li>引入风险分析，使软件在无法排除重大风险时有机会停止，以减小损失</li>
</ol>
<h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li>螺旋模型强调风险分析，但说服外部客户接受和相信分析结果并做出相关反应并不容易，因此螺旋模型往往比较适合内部的大规模软件开发。</li>
<li>风险分析需要耗费相当的成本，因此螺旋模型比较适合投资规模较大的软件项目。</li>
<li>失误的风险分析可能带来更大的风险。</li>
</ol>
<h2 id="简述统一过程三大特点，与面向对象的方法有什么关系？"><a href="#简述统一过程三大特点，与面向对象的方法有什么关系？" class="headerlink" title="简述统一过程三大特点，与面向对象的方法有什么关系？"></a>简述统一过程三大特点，与面向对象的方法有什么关系？</h2><h3 id="三大特点"><a href="#三大特点" class="headerlink" title="三大特点"></a>三大特点</h3><ol>
<li>用例驱动：用例驱动表明开发过程是沿着一个流（一系列从用例得到的工作流）前进的：用例被确定、用例被设计、用例被测试（最后用例又成为测试人员构造测试用例的基础）</li>
<li>以架构为中心：软件构架包含了系统中最重要的静态和动态特征。构架刻画了系统的整体设计，去掉了细节部分，突出了系统的重要特性。</li>
<li>迭代和增量的：软件开发是一项复杂的过程，因此可以将这些项目划分为切实可行并能够产生一个增量的迭代过程。迭代是指工作流中的步骤，增量是指产品中增加的部分。</li>
</ol>
<p>它将软件开发过程要素和软件工件要素整合在统一的软件工程框架中，是一个面向对象的程序开发方法论。</p>
<h2 id="简述统一过程四个阶段的划分准则是什么？每个阶段关键的里程碑是什么？"><a href="#简述统一过程四个阶段的划分准则是什么？每个阶段关键的里程碑是什么？" class="headerlink" title="简述统一过程四个阶段的划分准则是什么？每个阶段关键的里程碑是什么？"></a>简述统一过程四个阶段的划分准则是什么？每个阶段关键的里程碑是什么？</h2><p>统一过程中的软件生命周期在时间维度上被分解为四个顺序的阶段：初始阶段 (Inception)、精化阶段 (Elaboration)、构建阶段(Construction) 和产品交付阶段 (Transition)。</p>
<ol>
<li>初始阶段 (Inception)：为系统建立业务案例 (Business Case) 并确定项目的边界。<ul>
<li>里程碑：生命周期目标 (Lifecycle Objective) 里程碑，包括一些重要的文档，如：项目构想 (Vision)、原始用例模型、原始业务风险评估、一个或者多个原型、原始业务案例等。通过对文档的评审确定用例需求理解正确、项目风险评估合理、阶段计划可行等</li>
</ul>
</li>
<li>精化阶段 (Elaboration)：分析问题领域，建立健全的体系结构基础，编制项目计划，完成项目中高风险需求部分的开发。<ul>
<li>里程碑：生命周期体系结构 (Lifecycle Architecture) 里程碑，包括风险分析文档、软件体系结构基线、项目计划、可执行的进化原型、初始版本的用户手册等。通过评审确定软件体系结构已经稳定、高风险的业务需求和技术机制已经解决、修订的项目计划可行等。</li>
</ul>
</li>
<li>构建阶段(Construction)：完成所有剩余的技术构件和稳定业务需求功能的开发，并集成为产品，详细测试所有功能。构建阶段只是一个制造过程，其重点放在管理资源及控制开发过程以优化成本、进度和质量。<ul>
<li>里程碑：初始运行能力 (Initial Operational Capability) 里程碑，包括可以运行的软件产品、用户手册等，它决定了产品是否可以在测试环境中进行部署。此刻，要确定软件、环境、用户是否可以开始系统的运行。</li>
</ul>
</li>
<li>产品交付阶段 (Transition)：确保软件对最终用户是可用的。产品化阶段可以跨越几次迭代，包括为发布做准备的产品测试，基于用户反馈的少量调整。<ul>
<li>里程碑：产品发布 (Product Release) 里程碑，确定最终目标是否实现，是否应该开始产品下一个版本的另一个开发周期。在一些情况下这个里程碑可能与下一个周期的初始阶段相重合。</li>
</ul>
</li>
</ol>
<h2 id="软件企业为什么能按固定节奏生产、固定周期发布软件产品？它给企业项目管理带来哪些好处？"><a href="#软件企业为什么能按固定节奏生产、固定周期发布软件产品？它给企业项目管理带来哪些好处？" class="headerlink" title="软件企业为什么能按固定节奏生产、固定周期发布软件产品？它给企业项目管理带来哪些好处？"></a>软件企业为什么能按固定节奏生产、固定周期发布软件产品？它给企业项目管理带来哪些好处？</h2><p>统一过程为企业按固定节奏生产、固定周期发布软件产品提供了依据。</p>
<p>统一过程中的软件生命周期在时间维度上被分解为四个顺序的阶段：初始阶段 (Inception)、精化阶段 (Elaboration)、构建阶段(Construction) 和产品交付阶段 (Transition)，可以使企业能有一个固定的节奏来生产；统一过程的迭代性，使得项目组能周期性地交付产品。</p>
<p>给企业项目管理带来的好处：</p>
<ol>
<li>在软件开发的早期就可以对关键的，影响大的风险进行处理</li>
<li>可以提出一个软件体系架构来指导开发</li>
<li>可以较早的得到一个可运行的系统，鼓舞开发团队的士气，增强项目成功的信心。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://7cthunder.github.io/2019/04/13/SWAD-Homework3/" data-id="cjx958t7v0002psrp6jbt6m41" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SWAD/">SWAD</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-SWAD-Homework2-md" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/12/SWAD-Homework2-md/" class="article-date">
  <time datetime="2019-04-12T09:36:12.000Z" itemprop="datePublished">2019-04-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/SWAD/">SWAD</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/12/SWAD-Homework2-md/">SWAD | Homework2</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="简答题"><a href="#简答题" class="headerlink" title="简答题"></a>简答题</h2><h3 id="用简短的语言给出对分析、设计的理解"><a href="#用简短的语言给出对分析、设计的理解" class="headerlink" title="用简短的语言给出对分析、设计的理解"></a>用简短的语言给出对分析、设计的理解</h3><ul>
<li>分析：对问题和需求的进行调查研究，关注系统需要”实现什么”</li>
<li>设计：定义系统或组件的体系结构、组件、接口和其他特征的过程。</li>
</ul>
<h3 id="用一句话描述面向对象的分析与设计的优势"><a href="#用一句话描述面向对象的分析与设计的优势" class="headerlink" title="用一句话描述面向对象的分析与设计的优势"></a>用一句话描述面向对象的分析与设计的优势</h3><p>面向对象的分析与设计让不同领域的人沟通更加地方便，系统更加简单易懂，因此更容易维护复用。</p>
<h3 id="简述-UML（统一建模语言）的作用"><a href="#简述-UML（统一建模语言）的作用" class="headerlink" title="简述 UML（统一建模语言）的作用"></a>简述 UML（统一建模语言）的作用</h3><p>UML（统一建模语言）是软件工程领域中一种通用的、开发的、建模语言，旨在可视化系统分析与设计的结果</p>
<h4 id="考试考哪些图"><a href="#考试考哪些图" class="headerlink" title="考试考哪些图"></a>考试考哪些图</h4><ul>
<li>用例图：用户角度：功能、执行者 </li>
<li>静态图：系统静态结构 <ul>
<li>类图：概念及关系 </li>
<li>对象图：某种状态或时间段内，系统中活跃的对象及其关系 </li>
<li>包图：描述系统的分解结构 </li>
</ul>
</li>
<li>行为图：系统的动态行为 <ul>
<li>交互图：描述对象间的消息传递<ul>
<li>顺序图：强调对象间消息发送的时序 </li>
<li>合作图：强调对象间的动态写作关系 </li>
</ul>
</li>
<li>状态图：对象的动态行为。状态 - 事件 - 状态迁移 - 响应动作 </li>
<li>活动图：描述系统为完成某功能而执行的操作序列 </li>
</ul>
</li>
<li>实现图：描述系统的组成和分布状况 <ul>
<li>构件图：组成部件及其关系 </li>
<li>部署图：物理体系结构及与软件单元的对应关系</li>
</ul>
</li>
</ul>
<h3 id="从软件本质的角度，解释软件范围（需求）控制的可行性"><a href="#从软件本质的角度，解释软件范围（需求）控制的可行性" class="headerlink" title="从软件本质的角度，解释软件范围（需求）控制的可行性"></a>从软件本质的角度，解释软件范围（需求）控制的可行性</h3><p>由于软件本身的复杂性、不可见性、不一致性、可变性，软件范围多数情况下对于客户和开发者都是模糊的，这形成软件产品与其他产品不同的开发过程。在多数情况下，客户与开发者能就项目的 20% 内容给出严格的需求约定，80% 的内容都是相对模糊的。换言之，围绕客户目标，发现并满足客户感兴趣的内容是最关键的，这表示软件范围控制是可行的。</p>
<h2 id="项目管理实践"><a href="#项目管理实践" class="headerlink" title="项目管理实践"></a>项目管理实践</h2><h3 id="看板使用练习"><a href="#看板使用练习" class="headerlink" title="看板使用练习"></a>看板使用练习</h3><p><img src="https://github.com/7cthunder/7cthunder.github.io/raw/master/assets/kanban.png" alt="image-20190412140818437"></p>
<h3 id="UML绘图工具练习"><a href="#UML绘图工具练习" class="headerlink" title="UML绘图工具练习"></a>UML绘图工具练习</h3><p><img src="https://github.com/7cthunder/7cthunder.github.io/raw/master/assets/umlet.png" alt></p>
<p>选自教材P49 Figure 1.5</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://7cthunder.github.io/2019/04/12/SWAD-Homework2-md/" data-id="cjx958t7o0000psrpswfhr2h1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SWAD/">SWAD</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-SWAD-Homework1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/13/SWAD-Homework1/" class="article-date">
  <time datetime="2019-03-13T15:28:10.000Z" itemprop="datePublished">2019-03-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/SWAD/">SWAD</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/13/SWAD-Homework1/">SWAD | Homework1</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="简答题"><a href="#简答题" class="headerlink" title="简答题"></a>简答题</h2><ul>
<li><p>软件工程的定义</p>
<p>软件工程是研究和应用如何以系统性的、规范化的、可定量的过程化方法去开发和维护软件，以及如何把经过时间考验而证明正确的管理技术和当前能够得到的最好的技术方法结合起来的学科。它涉及到程序设计语言、数据库、软件开发工具、系统平台、标准、设计模式等方面。</p>
</li>
<li><p>解释导致 software crisis 本质原因、表现，述说克服软件危机的方法</p>
<ul>
<li>本质原因：由于软件的大量需求与软件生产力效率之间的矛盾以及软件系统的复杂性与软件开发方法之间的矛盾</li>
<li>表现：<ul>
<li>项目运行超出预算</li>
<li>项目运行超过时间</li>
<li>软件质量低落</li>
<li>软件通常不匹配需求</li>
<li>项目无法管理，且代码难以维护</li>
</ul>
</li>
<li>克服软件危机的方法：<ul>
<li>借鉴其他工程项目中行之有效的原理、概念、技术与方法，特别是吸取人类从事计算机硬件研究和开发的经验教训。在开发软件的过程中做到良好的组织，严格的管理，相互友好的协作。</li>
<li>推广在实践中总结出来的开发软件的成功的技术和方法，并研究更好、更有效的技术和方法，尽快克服在计算机系统早期发展阶段形成的一些错误概念和做法。</li>
<li>根据不同的应用领域，开发更好的软件工具并使用这些工具。将软件开发各个阶段使用的软件工具合成一个整体，形成一个良好的软件开发环境。</li>
</ul>
</li>
</ul>
</li>
<li><p>软件生命周期</p>
<p>在时间维度，对软件项目任务进行划分，又成为软件开发过程。常见有瀑布模型、螺旋模型、敏捷的模型等。</p>
</li>
<li><p>SWEBoK 的 15 个知识域</p>
<ul>
<li><p>Software Requirements 软件需求</p>
<p>软件需求表达了对软件产品的需求和约束，这些需求和约束有助于解决一些实际问题。</p>
</li>
<li><p>Software Design 软件设计</p>
<p>设计是定义系统或组件的体系结构、组件、接口和其他特征的过程、以及该过程的结果。</p>
</li>
<li><p>Software Construction 软件构造</p>
<p>通过详细设计、编码、单元测试、集成测试、调试和验证相结合，对工作软件进行详细的创建。</p>
</li>
<li><p>Software Testing 软件测试</p>
<p>为了验证产品质量并且通过指出缺陷来增进软件质量的活动。</p>
</li>
<li><p>Software Maintenance 软件维护</p>
<p>包括增强现有的功能，使得软件在新的环境中运行以及修正缺陷。</p>
</li>
<li><p>Software Configuration Management 软件配置管理</p>
<p>软件配置管理(Software Configuration Management)： 系统的配置是硬件、固件、软件或它们的组合的功能和/或物理特征。它还可以看作是硬件、固件或软件项目的特定版本的集合，为了服务于特定的目的，将这些硬件、固件和软件项目根据特定的构建过程组合在一起。因此，软件配置管理(SCM)是在不同的时间点识别系统配置的规程，以便系统地控制配置的更改，并在整个软件生命周期中维护配置的完整性和可追溯性。</p>
</li>
<li><p>Software Engineering Management 软件工程管理</p>
<p>包括计划、协调、测量、报告和控制一个项目或程序，确保软件的开发和维护是系统的、规范化的、可定量的。</p>
</li>
<li><p>Software Engineering Process 软件工程过程</p>
<p>软件工程知识领域关注软件生命周期过程的定义，实现，评估，测量，管理和改进。主题包括过程实现和改变(过程基础设施，过程实现和改变模型，和软件过程管理)，过程定义(软件生命周期模型和过程，过程定义，过程适应和自动化过程的符号)，过程评估模型和方法，测量(过程测量，产品测量，技术测量和测量结果质量)和软件过程工具。</p>
</li>
<li><p>Software Engineering Models and Methods 软件工程模型和方法</p>
<p>软件工程技术和管理的原理、原则、方法</p>
</li>
<li><p>Software Quality 软件质量</p>
<p>软件质量是软件生命周期普遍关注的，存在于许多 SWEBOK V3 知识领域中。此外，软件质量知识领域包括软件质量基础(软件工程文化，软件质量特征，软件质量价值和成本和软件质量改进)，软件质量管理过程(软件质量保证，认证和确认，审核和审计)和实际考量(缺陷特征，软件质量测量和软件质量工具)。</p>
</li>
<li><p>Software Engineering Professional Practice 软件工程专业实践</p>
<p>软件工程专业实践关注软件工程师必须具备的知识，技巧和态度，以用一种专业，负责和正直的态度来时间软件工程。软件工程专业实践知识领域涵盖专业性(专业行为，专业协会，软件工程标准，雇佣合同和法律问题)，道德准则，动态小组(团队合作，认知问题复杂性，与利益相关者交互，不确定性和模糊性的处理，多元环境处理)和交流技巧。</p>
</li>
<li><p>Software Engineering Economics 软件工程经济学</p>
<p>软件工程经济学知识领域关注在商业环境中做出决策，以使技术决策和商业目标达成一致。</p>
</li>
<li><p>Computing Foundations 计算基础</p>
<p>计算基础知识领域涵盖对于软件工程实践必须的计算背景的基础主题。涵盖主题包括问题解决技术，抽象，算法和复杂度，编程基础，并行和分布式计算基础，计算机组成，操作系统和网络通信。</p>
</li>
<li><p>Mathematical Foundations</p>
<p>数学基础知识领域涵盖对于软件工程实践必须的数学背景的基础主题。涵盖的主题包括集合，关系和函数，基础命题和谓词逻辑，证明技术，图和树，离散概率，语法和有限状态机，数论。</p>
</li>
<li><p>Engineering Foundations</p>
<p>工程基础知识领域涵盖对于软件工程实践必须的工程背景的基础主题。涵盖的主题包括经验方法和实验技术，统计分析，测量和指标，工程设计，模拟和建模，根本原因分析。</p>
</li>
</ul>
</li>
<li><p>CMMI 的五个级别</p>
<ul>
<li>Level 1 - Initial: 没有可预知的生产过程，缺乏控制和应变能力</li>
<li>Level 2 - Managed: 生产过程为每个项目特制，一般有一定的应变能力。</li>
<li>Level 3 - Defined: 生产过程为组织所定制，并且积极主动。</li>
<li>Level 4 - Quantitatively Managed: 生产过程可测度（预知）且可控。</li>
<li>Level 5 - Optimizing: 生产专注于过程优化。</li>
</ul>
</li>
<li><p>用自己语言简述 SWEBok 或 CMMI</p>
<p>CMMI 全称为能力成熟度模型集成，其本质上就是衡量软件工程的成熟度的五个级别。CMMI可以帮助企业确认当前软件工程处于的级别并且对其进行管理和改进，增强软件的开发和改进能力。其目的就在于使得软件可以在限定时间和预算内完成并且保证其高质量。CMMI分为五个级别，分别是无序、已管理、已定义、量化管理和优化，这五个级别对于软件工程的管理规范一级比一级要严格，是一个渐进性的模型框架，指导了企业对于现有的软件工程进行评估和改进以及开始新的系统性规范化的软件工程。其主要关注点在于：成本效益、明确重过程集中和灵活性。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://7cthunder.github.io/2019/03/13/SWAD-Homework1/" data-id="cjx958t810006psrpm5ydyj0m" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SWAD/">SWAD</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-服务计算-gorilla-mux-源码解析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/15/服务计算-gorilla-mux-源码解析/" class="article-date">
  <time datetime="2018-11-15T11:29:55.000Z" itemprop="datePublished">2018-11-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Go/">Go</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/15/服务计算-gorilla-mux-源码解析/">服务计算 | gorilla/mux 源码解析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="gorilla-mux-源码解析"><a href="#gorilla-mux-源码解析" class="headerlink" title="gorilla/mux 源码解析"></a>gorilla/mux 源码解析</h1><p>在开始阅读 <code>gorilla/mux</code> 源码之前，不妨让我们看看 <code>Golang</code> 的 <code>net/http</code> 包是怎么实现多路复用的。</p>
<h2 id="net-http"><a href="#net-http" class="headerlink" title="net/http"></a>net/http</h2><p>用一个简单的例子过一下流程:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Hello world, the web server</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"io"</span></span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	helloHandler := <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">		io.WriteString(w, <span class="string">"Hello, world!\n"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	http.HandleFunc(<span class="string">"/hello"</span>, helloHandler)</span><br><span class="line">	log.Fatal(http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先我们调用了 <code>http.HandleFunc</code> 来为 <code>/hello</code> 注册一个 <code>Handler</code>：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.HandleFunc(<span class="string">"/hello"</span>, helloHandler)</span><br></pre></td></tr></table></figure></p>
<p>依次调用下面三个函数/方法，第一个函数表明当我们使用 http.HandleFunc 时默认是注册在 <code>DefaultServeMux</code> 这个默认的多路复用器上；第二个方法中 <code>HandlerFunc(handler)</code> 意思是将 <code>handler</code> 强制转化为 <code>HandlerFunc</code> 因为其实现了 <code>http.Handler</code> 这个接口；第三个方法在 mux.m 中查找是否已为该 <code>URL</code> 注册 <code>handler</code> ，如果有就报错，没有就为其注册：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ServeMux *</span></span><br><span class="line"><span class="keyword">type</span> ServeMux <span class="keyword">struct</span> &#123;</span><br><span class="line">	mu    sync.RWMutex</span><br><span class="line">	m     <span class="keyword">map</span>[<span class="keyword">string</span>]muxEntry</span><br><span class="line">	hosts <span class="keyword">bool</span> <span class="comment">// whether any patterns contain hostnames</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HandleFunc registers the handler function for the given pattern</span></span><br><span class="line"><span class="comment">// in the DefaultServeMux.</span></span><br><span class="line"><span class="comment">// The documentation for ServeMux explains how patterns are matched.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span>)</span> &#123;</span><br><span class="line">	DefaultServeMux.HandleFunc(pattern, handler)</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// HandleFunc registers the handler function for the given pattern.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span>)</span> &#123;</span><br><span class="line">	mux.Handle(pattern, HandlerFunc(handler))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Handle registers the handler for the given pattern.</span></span><br><span class="line"><span class="comment">// If a handler already exists for pattern, Handle panics.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">Handle</span><span class="params">(pattern <span class="keyword">string</span>, handler Handler)</span></span> &#123;</span><br><span class="line">	mux.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> mux.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> pattern == <span class="string">""</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"http: invalid pattern"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> handler == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"http: nil handler"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> _, exist := mux.m[pattern]; exist &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"http: multiple registrations for "</span> + pattern)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> mux.m == <span class="literal">nil</span> &#123;</span><br><span class="line">		mux.m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]muxEntry)</span><br><span class="line">	&#125;</span><br><span class="line">	mux.m[pattern] = muxEntry&#123;h: handler, pattern: pattern&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> pattern[<span class="number">0</span>] != <span class="string">'/'</span> &#123;</span><br><span class="line">		mux.hosts = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来是调用：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure></p>
<p>本文不打算追踪启动 <code>server</code> 的整个过程，不了解或者感兴趣的可以看看 <a href="https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/03.4.md" target="_blank" rel="noopener">Go的http包详解</a> 。我们只挑对我们讲解多路复用感兴趣的部分来讲解，下面看看：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sh serverHandler)</span> <span class="title">ServeHTTP</span><span class="params">(rw ResponseWriter, req *Request)</span></span> &#123;</span><br><span class="line">	handler := sh.srv.Handler</span><br><span class="line">	<span class="keyword">if</span> handler == <span class="literal">nil</span> &#123;</span><br><span class="line">		handler = DefaultServeMux</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> req.RequestURI == <span class="string">"*"</span> &amp;&amp; req.Method == <span class="string">"OPTIONS"</span> &#123;</span><br><span class="line">		handler = globalOptionsHandler&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	handler.ServeHTTP(rw, req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的方法表明当我们在调用 <code>http.ListenAndServe(&quot;:8080&quot;, nil)</code> 没有给 <code>handler</code> 的时候，默认使用 <code>DefaultServeMux</code> ，所以上面的例子调用的是 <code>DefaultServeMux</code> 的 <code>ServeHTTP</code>：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ServeHTTP dispatches the request to the handler whose</span></span><br><span class="line"><span class="comment">// pattern most closely matches the request URL.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">ServeHTTP</span><span class="params">(w ResponseWriter, r *Request)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> r.RequestURI == <span class="string">"*"</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> r.ProtoAtLeast(<span class="number">1</span>, <span class="number">1</span>) &#123;</span><br><span class="line">			w.Header().Set(<span class="string">"Connection"</span>, <span class="string">"close"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		w.WriteHeader(StatusBadRequest)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	h, _ := mux.Handler(r)</span><br><span class="line">	h.ServeHTTP(w, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>让我们看看 <code>DefaultServeMux</code> 是如何查找相应的 <code>handler</code> ，看看 <code>match</code> 的实现，只能简单地实现字符串匹配，用起来不够爽吧？<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Find a handler on a handler map given a path string.</span></span><br><span class="line"><span class="comment">// Most-specific (longest) pattern wins.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">match</span><span class="params">(path <span class="keyword">string</span>)</span> <span class="params">(h Handler, pattern <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// Check for exact match first.</span></span><br><span class="line">	v, ok := mux.m[path]</span><br><span class="line">	<span class="keyword">if</span> ok &#123;</span><br><span class="line">		<span class="keyword">return</span> v.h, v.pattern</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Check for longest valid match.</span></span><br><span class="line">	<span class="keyword">var</span> n = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> mux.m &#123;</span><br><span class="line">		<span class="keyword">if</span> !pathMatch(k, path) &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> h == <span class="literal">nil</span> || <span class="built_in">len</span>(k) &gt; n &#123;</span><br><span class="line">			n = <span class="built_in">len</span>(k)</span><br><span class="line">			h = v.h</span><br><span class="line">			pattern = v.pattern</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当然，复杂也可能意味着性能下降，有兴趣的同学可以看看 <a href="https://github.com/julienschmidt/go-http-routing-benchmark/blob/master/README.md" target="_blank" rel="noopener">Go HTTP Router Benchmark</a> ，毕竟系统是拿来用的，不只是拿来写的。不过作为一个合格的程序员，应该学会用轮子，所以让我们看看 <code>gorilla/mux</code> 是怎么实现路由的吧。</p>
<h2 id="gorilla-mux"><a href="#gorilla-mux" class="headerlink" title="gorilla/mux"></a>gorilla/mux</h2><p>一个简单使用的例子（摘自<a href="https://github.com/gorilla/mux#graceful-shutdown" target="_blank" rel="noopener">官方文档</a>）：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"github.com/gorilla/mux"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">YourHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    w.Write([]<span class="keyword">byte</span>(<span class="string">"Gorilla!\n"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := mux.NewRouter()</span><br><span class="line">    <span class="comment">// Routes consist of a path and a handler function.</span></span><br><span class="line">    r.HandleFunc(<span class="string">"/"</span>, YourHandler)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bind to a port and pass our router in</span></span><br><span class="line">    log.Fatal(http.ListenAndServe(<span class="string">":8000"</span>, r))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一些进阶用法：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以匹配 URL 中的变量</span></span><br><span class="line">r := mux.NewRouter()</span><br><span class="line">r.HandleFunc(<span class="string">"/products/&#123;key&#125;"</span>, ProductHandler)</span><br><span class="line">r.HandleFunc(<span class="string">"/articles/&#123;category&#125;/"</span>, ArticlesCategoryHandler)</span><br><span class="line">r.HandleFunc(<span class="string">"/articles/&#123;category&#125;/&#123;id:[0-9]+&#125;"</span>, ArticleHandler)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用匹配的变量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ArticlesCategoryHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    vars := mux.Vars(r)</span><br><span class="line">    w.WriteHeader(http.StatusOK)</span><br><span class="line">    fmt.Fprintf(w, <span class="string">"Category: %v\n"</span>, vars[<span class="string">"category"</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路径前缀</span></span><br><span class="line">r.PathPrefix(<span class="string">"/products/"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Only matches if domain is "www.example.com".</span></span><br><span class="line">r.Host(<span class="string">"www.example.com"</span>)</span><br><span class="line"><span class="comment">// Matches a dynamic subdomain.</span></span><br><span class="line">r.Host(<span class="string">"&#123;subdomain:[a-z]+&#125;.domain.com"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子路由</span></span><br><span class="line">r := mux.NewRouter()</span><br><span class="line">s := r.Host(<span class="string">"www.example.com"</span>).Subrouter()</span><br></pre></td></tr></table></figure></p>
<p>ok，总之它的功能比官方包要强大的多，下面开始源码分析。</p>
<h3 id="mux-go"><a href="#mux-go" class="headerlink" title="mux.go"></a>mux.go</h3><p>先看看其数据结构，与 <code>http.ServeMux</code> 相比，要多出不少东西，我们主要关注 <code>routes</code> 、<code>parent</code> 以及三个 <code>flag</code>：<code>strictSlash</code>、<code>skipClean</code>、<code>useEncodedPath</code>。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This will send all incoming requests to the router.</span></span><br><span class="line"><span class="keyword">type</span> Router <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// Configurable Handler to be used when no route matches.</span></span><br><span class="line">	NotFoundHandler http.Handler</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Configurable Handler to be used when the request method does not match the route.</span></span><br><span class="line">	MethodNotAllowedHandler http.Handler</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Parent route, if this is a subrouter.</span></span><br><span class="line">	parent parentRoute</span><br><span class="line">	<span class="comment">// Routes to be matched, in order.</span></span><br><span class="line">	routes []*Route</span><br><span class="line">	<span class="comment">// Routes by name for URL building.</span></span><br><span class="line">	namedRoutes <span class="keyword">map</span>[<span class="keyword">string</span>]*Route</span><br><span class="line">	<span class="comment">// See Router.StrictSlash(). This defines the flag for new routes.</span></span><br><span class="line">	strictSlash <span class="keyword">bool</span></span><br><span class="line">	<span class="comment">// See Router.SkipClean(). This defines the flag for new routes.</span></span><br><span class="line">	skipClean <span class="keyword">bool</span></span><br><span class="line">	<span class="comment">// If true, do not clear the request context after handling the request.</span></span><br><span class="line">	<span class="comment">// This has no effect when go1.7+ is used, since the context is stored</span></span><br><span class="line">	<span class="comment">// on the request itself.</span></span><br><span class="line">	KeepContext <span class="keyword">bool</span></span><br><span class="line">	<span class="comment">// see Router.UseEncodedPath(). This defines a flag for all routes.</span></span><br><span class="line">	useEncodedPath <span class="keyword">bool</span></span><br><span class="line">	<span class="comment">// Slice of middlewares to be called after a match is found</span></span><br><span class="line">	middlewares []middleware</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中三个 <code>flag</code> 只要看注释就知道它们的作用了，不多解释：</p>
<ul>
<li><p>strictSlash</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StrictSlash defines the trailing slash behavior for new routes. The initial</span></span><br><span class="line"><span class="comment">// value is false.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// When true, if the route path is "/path/", accessing "/path" will perform a redirect</span></span><br><span class="line"><span class="comment">// to the former and vice versa. In other words, your application will always</span></span><br><span class="line"><span class="comment">// see the path as specified in the route.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// When false, if the route path is "/path", accessing "/path/" will not match</span></span><br><span class="line"><span class="comment">// this route and vice versa.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Router)</span> <span class="title">StrictSlash</span><span class="params">(value <span class="keyword">bool</span>)</span> *<span class="title">Router</span></span> &#123;</span><br><span class="line">    r.strictSlash = value</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>skipClean</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SkipClean defines the path cleaning behaviour for new routes. The initial</span></span><br><span class="line"><span class="comment">// value is false. Users should be careful about which routes are not cleaned</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// When true, if the route path is "/path//to", it will remain with the double</span></span><br><span class="line"><span class="comment">// slash. This is helpful if you have a route like: /fetch/http://xkcd.com/534/</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// When false, the path will be cleaned, so /fetch/http://xkcd.com/534/ will</span></span><br><span class="line"><span class="comment">// become /fetch/http/xkcd.com/534</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Router)</span> <span class="title">SkipClean</span><span class="params">(value <span class="keyword">bool</span>)</span> *<span class="title">Router</span></span> &#123;</span><br><span class="line">    r.skipClean = value</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>useEncodedPath</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UseEncodedPath tells the router to match the encoded original path</span></span><br><span class="line"><span class="comment">// to the routes.</span></span><br><span class="line"><span class="comment">// For eg. "/path/foo%2Fbar/to" will match the path "/path/&#123;var&#125;/to".</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If not called, the router will match the unencoded path to the routes.</span></span><br><span class="line"><span class="comment">// For eg. "/path/foo%2Fbar/to" will match the path "/path/foo/bar/to"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Router)</span> <span class="title">UseEncodedPath</span><span class="params">()</span> *<span class="title">Router</span></span> &#123;</span><br><span class="line">    r.useEncodedPath = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>先看看它的 <code>HandleFunc</code> ，首先 <code>NewRoute</code> 创建一个 <code>Route</code> ，然后 <code>Path</code> 为 <code>path</code> 添加一个 <code>matcher</code> ，最后 <code>HandlerFunc</code> 为其设置一个 <code>handler</code> ：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HandleFunc registers a new route with a matcher for the URL path.</span></span><br><span class="line"><span class="comment">// See Route.Path() and Route.HandlerFunc().</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Router)</span> <span class="title">HandleFunc</span><span class="params">(path <span class="keyword">string</span>, f <span class="keyword">func</span>(http.ResponseWriter,</span></span></span><br><span class="line"><span class="function"><span class="params">	*http.Request)</span>) *<span class="title">Route</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> r.NewRoute().Path(path).HandlerFunc(f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其次看看 <code>Router</code> 的 <code>ServeHTTP</code> ，先使用上面说的 <code>flag</code> 对 <code>Request</code> 中的 <code>URL</code> 进行预处理，然后使用 <code>Router</code> 的 <code>Match</code> 方法查找 <code>handler</code>。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ServeHTTP dispatches the handler registered in the matched route.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// When there is a match, the route variables can be retrieved calling</span></span><br><span class="line"><span class="comment">// mux.Vars(request).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Router)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> !r.skipClean &#123;</span><br><span class="line">		path := req.URL.Path</span><br><span class="line">		<span class="keyword">if</span> r.useEncodedPath &#123;</span><br><span class="line">			path = req.URL.EscapedPath()</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Clean path to canonical form and redirect.</span></span><br><span class="line">		<span class="keyword">if</span> p := cleanPath(path); p != path &#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Added 3 lines (Philip Schlump) - It was dropping the query string and #whatever from query.</span></span><br><span class="line">			<span class="comment">// This matches with fix in go 1.2 r.c. 4 for same problem.  Go Issue:</span></span><br><span class="line">			<span class="comment">// http://code.google.com/p/go/issues/detail?id=5252</span></span><br><span class="line">			url := *req.URL</span><br><span class="line">			url.Path = p</span><br><span class="line">			p = url.String()</span><br><span class="line"></span><br><span class="line">			w.Header().Set(<span class="string">"Location"</span>, p)</span><br><span class="line">			w.WriteHeader(http.StatusMovedPermanently)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> match RouteMatch</span><br><span class="line">	<span class="keyword">var</span> handler http.Handler</span><br><span class="line">	<span class="keyword">if</span> r.Match(req, &amp;match) &#123;</span><br><span class="line">		handler = match.Handler</span><br><span class="line">		req = setVars(req, match.Vars)</span><br><span class="line">		req = setCurrentRoute(req, match.Route)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> handler == <span class="literal">nil</span> &amp;&amp; match.MatchErr == ErrMethodMismatch &#123;</span><br><span class="line">		handler = methodNotAllowedHandler()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> handler == <span class="literal">nil</span> &#123;</span><br><span class="line">		handler = http.NotFoundHandler()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !r.KeepContext &#123;</span><br><span class="line">		<span class="keyword">defer</span> contextClear(req)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	handler.ServeHTTP(w, req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>再看看 <code>Router</code> 的 <code>Match</code> 方法，遍历 <code>Router</code> 下的所有 <code>route</code> 看看是否匹配：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Match attempts to match the given request against the router's registered routes.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If the request matches a route of this router or one of its subrouters the Route,</span></span><br><span class="line"><span class="comment">// Handler, and Vars fields of the the match argument are filled and this function</span></span><br><span class="line"><span class="comment">// returns true.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If the request does not match any of this router's or its subrouters' routes</span></span><br><span class="line"><span class="comment">// then this function returns false. If available, a reason for the match failure</span></span><br><span class="line"><span class="comment">// will be filled in the match argument's MatchErr field. If the match failure type</span></span><br><span class="line"><span class="comment">// (eg: not found) has a registered handler, the handler is assigned to the Handler</span></span><br><span class="line"><span class="comment">// field of the match argument.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Router)</span> <span class="title">Match</span><span class="params">(req *http.Request, match *RouteMatch)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, route := <span class="keyword">range</span> r.routes &#123;</span><br><span class="line">		<span class="keyword">if</span> route.Match(req, match) &#123;</span><br><span class="line">			<span class="comment">// Build middleware chain if no error was found</span></span><br><span class="line">			<span class="keyword">if</span> match.MatchErr == <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">for</span> i := <span class="built_in">len</span>(r.middlewares) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">					match.Handler = r.middlewares[i].Middleware(match.Handler)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">// 省略</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这里我们还不能看出 <code>Router</code> 是怎么实现如此强大的路由的，因为重点是 Route。</p>
<h3 id="route-go"><a href="#route-go" class="headerlink" title="route.go"></a>route.go</h3><p>照例看看数据结构，有父路由 <code>parent</code> 、处理器 <code>handler</code> 、匹配器表 <code>matchers</code> 、正则表达式 <code>regexp</code> 以及前面提到的三个 <code>flag</code> 等：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Route stores information to match a request and build URLs.</span></span><br><span class="line"><span class="keyword">type</span> Route <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// Parent where the route was registered (a Router).</span></span><br><span class="line">	parent parentRoute</span><br><span class="line">	<span class="comment">// Request handler for the route.</span></span><br><span class="line">	handler http.Handler</span><br><span class="line">	<span class="comment">// List of matchers.</span></span><br><span class="line">	matchers []matcher</span><br><span class="line">	<span class="comment">// Manager for the variables from host and path.</span></span><br><span class="line">	regexp *routeRegexpGroup</span><br><span class="line">	<span class="comment">// If true, when the path pattern is "/path/", accessing "/path" will</span></span><br><span class="line">	<span class="comment">// redirect to the former and vice versa.</span></span><br><span class="line">	strictSlash <span class="keyword">bool</span></span><br><span class="line">	<span class="comment">// If true, when the path pattern is "/path//to", accessing "/path//to"</span></span><br><span class="line">	<span class="comment">// will not redirect</span></span><br><span class="line">	skipClean <span class="keyword">bool</span></span><br><span class="line">	<span class="comment">// If true, "/path/foo%2Fbar/to" will match the path "/path/&#123;var&#125;/to"</span></span><br><span class="line">	useEncodedPath <span class="keyword">bool</span></span><br><span class="line">	<span class="comment">// The scheme used when building URLs.</span></span><br><span class="line">	buildScheme <span class="keyword">string</span></span><br><span class="line">	<span class="comment">// If true, this route never matches: it is only used to build URLs.</span></span><br><span class="line">	buildOnly <span class="keyword">bool</span></span><br><span class="line">	<span class="comment">// The name used to build URLs.</span></span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	<span class="comment">// Error resulted from building a route.</span></span><br><span class="line">	err error</span><br><span class="line"></span><br><span class="line">	buildVarsFunc BuildVarsFunc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>还记得前面创建 <code>Route</code> 后使用的 <code>Path</code> 方法吧，它能为 <code>URL path</code> 添加一个正则表达式匹配器：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Path adds a matcher for the URL path.</span></span><br><span class="line"><span class="comment">// It accepts a template with zero or more URL variables enclosed by &#123;&#125;. The</span></span><br><span class="line"><span class="comment">// template must start with a "/".</span></span><br><span class="line"><span class="comment">// Variables can define an optional regexp pattern to be matched:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// - &#123;name&#125; matches anything until the next slash.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// - &#123;name:pattern&#125; matches the given regexp pattern.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// For example:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//     r := mux.NewRouter()</span></span><br><span class="line"><span class="comment">//     r.Path("/products/").Handler(ProductsHandler)</span></span><br><span class="line"><span class="comment">//     r.Path("/products/&#123;key&#125;").Handler(ProductsHandler)</span></span><br><span class="line"><span class="comment">//     r.Path("/articles/&#123;category&#125;/&#123;id:[0-9]+&#125;").</span></span><br><span class="line"><span class="comment">//       Handler(ArticleHandler)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Variable names must be unique in a given route. They can be retrieved</span></span><br><span class="line"><span class="comment">// calling mux.Vars(request).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Route)</span> <span class="title">Path</span><span class="params">(tpl <span class="keyword">string</span>)</span> *<span class="title">Route</span></span> &#123;</span><br><span class="line">	r.err = r.addRegexpMatcher(tpl, regexpTypePath)</span><br><span class="line">	<span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里就不打算再深入下去探究如何添加的啦，一来作者水平有限，二来大家有不同的实现方式，所以我们就且停留到这一层吧。下面看看 <code>Route</code> 的 <code>Match</code> ：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Match matches the route against the request.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Route)</span> <span class="title">Match</span><span class="params">(req *http.Request, match *RouteMatch)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> r.buildOnly || r.err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> matchErr error</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Match everything.</span></span><br><span class="line">	<span class="keyword">for</span> _, m := <span class="keyword">range</span> r.matchers &#123;</span><br><span class="line">		<span class="keyword">if</span> matched := m.Match(req, match); !matched &#123;</span><br><span class="line">			<span class="keyword">if</span> _, ok := m.(methodMatcher); ok &#123;</span><br><span class="line">				matchErr = ErrMethodMismatch</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			matchErr = <span class="literal">nil</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> matchErr != <span class="literal">nil</span> &#123;</span><br><span class="line">		match.MatchErr = matchErr</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> match.MatchErr == ErrMethodMismatch &#123;</span><br><span class="line">		<span class="comment">// We found a route which matches request method, clear MatchErr</span></span><br><span class="line">		match.MatchErr = <span class="literal">nil</span></span><br><span class="line">		<span class="comment">// Then override the mis-matched handler</span></span><br><span class="line">		match.Handler = r.handler</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Yay, we have a match. Let's collect some info about it.</span></span><br><span class="line">	<span class="keyword">if</span> match.Route == <span class="literal">nil</span> &#123;</span><br><span class="line">		match.Route = r</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> match.Handler == <span class="literal">nil</span> &#123;</span><br><span class="line">		match.Handler = r.handler</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> match.Vars == <span class="literal">nil</span> &#123;</span><br><span class="line">		match.Vars = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Set variables.</span></span><br><span class="line">	<span class="keyword">if</span> r.regexp != <span class="literal">nil</span> &#123;</span><br><span class="line">		r.regexp.setMatch(req, match, r)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>到这里大家可能会疑惑了，<code>// Match everything</code> 指的是什么，其实一个 <code>Route</code> 可以存在多个 <code>matcher</code>，也就是说，你可能设置了一个这样的路由:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r.HandleFunc(<span class="string">"/products"</span>, ProductsHandler).</span><br><span class="line">  Host(<span class="string">"www.example.com"</span>).</span><br><span class="line">  Methods(<span class="string">"GET"</span>).</span><br><span class="line">  Schemes(<span class="string">"http"</span>)</span><br></pre></td></tr></table></figure></p>
<p>那么这个路由就需要满足上述 4 个 <code>matcher</code> 才能够匹配成功，而 <code>Path</code> 和 <code>Host</code> 都是通过添加 <code>routeRegexp</code> 来实现，<code>Methods</code> 和 <code>Schemes</code> 则分别实现了各自的 <code>matcher</code>：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Path and Host add RegexpMatcher</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Route)</span> <span class="title">Path</span><span class="params">(tpl <span class="keyword">string</span>)</span> *<span class="title">Route</span></span> &#123;</span><br><span class="line">	r.err = r.addRegexpMatcher(tpl, regexpTypePath)</span><br><span class="line">	<span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Route)</span> <span class="title">Host</span><span class="params">(tpl <span class="keyword">string</span>)</span> *<span class="title">Route</span></span> &#123;</span><br><span class="line">	r.err = r.addRegexpMatcher(tpl, regexpTypeHost)</span><br><span class="line">	<span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// methodMatcher matches the request against HTTP methods.</span></span><br><span class="line"><span class="keyword">type</span> methodMatcher []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m methodMatcher)</span> <span class="title">Match</span><span class="params">(r *http.Request, match *RouteMatch)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> matchInArray(m, r.Method)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// schemeMatcher matches the request against URL schemes.</span></span><br><span class="line"><span class="keyword">type</span> schemeMatcher []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m schemeMatcher)</span> <span class="title">Match</span><span class="params">(r *http.Request, match *RouteMatch)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> matchInArray(m, r.URL.Scheme)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>你有可能看了我的分析以后更晕了，但是没关系，你只要记住 <code>gorilla/mux</code> 大致是怎么实现路由的就好：</p>
<ol>
<li><p>使用 <code>Router</code> 的 <code>HandleFunc</code> 、<code>Host</code> 、 <code>Methods</code> 、 <code>Schemes</code> 、 <code>Headers</code> 等方法会创建一个路由并且为其添加相应类型 <code>matcher</code>，当然你也可以使用 <code>MatcherFunc</code> 来创建自己的 <code>matcher</code>。如果你想为一个路由添加多个方法，那么你可以这样：</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r.HandleFunc(<span class="string">"/products"</span>, ProductsHandler).</span><br><span class="line">Host(<span class="string">"www.example.com"</span>).</span><br><span class="line">Methods(<span class="string">"GET"</span>).</span><br><span class="line">Schemes(<span class="string">"http)</span></span><br></pre></td></tr></table></figure>
<p> 因为上面说的每个方法都会返回一个刚创建 Route 的指针，这样你就可以使用 Route 的同名方法来添加 matcher 了。</p>
</li>
<li><p><code>gorilla/mux</code> 会查找 <code>Router</code> 下的 <code>Route</code> 列表，找到是否有无匹配的路由，而 <code>Route</code> 会遍历其 <code>matchers</code> 列表来看看是否满足所有的 <code>matchers</code>，只要一个不匹配，则失败。</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://7cthunder.github.io/2018/11/15/服务计算-gorilla-mux-源码解析/" data-id="cjx958t8o000spsrpgm172czp" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Go/">Go</a></li></ul>

    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Go/">Go</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/RESTful/">RESTful</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/SWAD/">SWAD</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Go/">Go</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mock/">Mock</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SWAD/">SWAD</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Swagger/">Swagger</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Go/" style="font-size: 10px;">Go</a> <a href="/tags/Mock/" style="font-size: 10px;">Mock</a> <a href="/tags/SWAD/" style="font-size: 20px;">SWAD</a> <a href="/tags/Swagger/" style="font-size: 10px;">Swagger</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/06/23/Swagger-Mock/">Swagger &amp; Mock</a>
          </li>
        
          <li>
            <a href="/2019/05/22/SWAD-Homework4/">SWAD | Homework4</a>
          </li>
        
          <li>
            <a href="/2019/04/13/SWAD-Homework3/">SWAD | Homework3</a>
          </li>
        
          <li>
            <a href="/2019/04/12/SWAD-Homework2-md/">SWAD | Homework2</a>
          </li>
        
          <li>
            <a href="/2019/03/13/SWAD-Homework1/">SWAD | Homework1</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 Sandra<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>