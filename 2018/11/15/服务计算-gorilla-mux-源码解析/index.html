<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>服务计算 | gorilla/mux 源码解析 | 7cthunder</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="gorilla/mux 源码解析在开始阅读 gorilla/mux 源码之前，不妨让我们看看 Golang 的 net/http 包是怎么实现多路复用的。 net/http用一个简单的例子过一下流程:1234567891011121314151617// Hello world, the web serverpackage mainimport (	&quot;io&quot;	&quot;log&quot;	&quot;net/http&quot;)fu">
<meta name="keywords" content="Go">
<meta property="og:type" content="article">
<meta property="og:title" content="服务计算 | gorilla&#x2F;mux 源码解析">
<meta property="og:url" content="http://yoursite.com/2018/11/15/服务计算-gorilla-mux-源码解析/index.html">
<meta property="og:site_name" content="7cthunder">
<meta property="og:description" content="gorilla/mux 源码解析在开始阅读 gorilla/mux 源码之前，不妨让我们看看 Golang 的 net/http 包是怎么实现多路复用的。 net/http用一个简单的例子过一下流程:1234567891011121314151617// Hello world, the web serverpackage mainimport (	&quot;io&quot;	&quot;log&quot;	&quot;net/http&quot;)fu">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-03-18T11:48:47.908Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="服务计算 | gorilla&#x2F;mux 源码解析">
<meta name="twitter:description" content="gorilla/mux 源码解析在开始阅读 gorilla/mux 源码之前，不妨让我们看看 Golang 的 net/http 包是怎么实现多路复用的。 net/http用一个简单的例子过一下流程:1234567891011121314151617// Hello world, the web serverpackage mainimport (	&quot;io&quot;	&quot;log&quot;	&quot;net/http&quot;)fu">
  
    <link rel="alternate" href="/atom.xml" title="7cthunder" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">7cthunder</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">这段代码我已经和小黄鸭商量过了。</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-服务计算-gorilla-mux-源码解析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/15/服务计算-gorilla-mux-源码解析/" class="article-date">
  <time datetime="2018-11-15T11:29:55.000Z" itemprop="datePublished">2018-11-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Go/">Go</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      服务计算 | gorilla/mux 源码解析
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="gorilla-mux-源码解析"><a href="#gorilla-mux-源码解析" class="headerlink" title="gorilla/mux 源码解析"></a>gorilla/mux 源码解析</h1><p>在开始阅读 <code>gorilla/mux</code> 源码之前，不妨让我们看看 <code>Golang</code> 的 <code>net/http</code> 包是怎么实现多路复用的。</p>
<h2 id="net-http"><a href="#net-http" class="headerlink" title="net/http"></a>net/http</h2><p>用一个简单的例子过一下流程:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Hello world, the web server</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"io"</span></span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	helloHandler := <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">		io.WriteString(w, <span class="string">"Hello, world!\n"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	http.HandleFunc(<span class="string">"/hello"</span>, helloHandler)</span><br><span class="line">	log.Fatal(http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先我们调用了 <code>http.HandleFunc</code> 来为 <code>/hello</code> 注册一个 <code>Handler</code>：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.HandleFunc(<span class="string">"/hello"</span>, helloHandler)</span><br></pre></td></tr></table></figure></p>
<p>依次调用下面三个函数/方法，第一个函数表明当我们使用 http.HandleFunc 时默认是注册在 <code>DefaultServeMux</code> 这个默认的多路复用器上；第二个方法中 <code>HandlerFunc(handler)</code> 意思是将 <code>handler</code> 强制转化为 <code>HandlerFunc</code> 因为其实现了 <code>http.Handler</code> 这个接口；第三个方法在 mux.m 中查找是否已为该 <code>URL</code> 注册 <code>handler</code> ，如果有就报错，没有就为其注册：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ServeMux *</span></span><br><span class="line"><span class="keyword">type</span> ServeMux <span class="keyword">struct</span> &#123;</span><br><span class="line">	mu    sync.RWMutex</span><br><span class="line">	m     <span class="keyword">map</span>[<span class="keyword">string</span>]muxEntry</span><br><span class="line">	hosts <span class="keyword">bool</span> <span class="comment">// whether any patterns contain hostnames</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HandleFunc registers the handler function for the given pattern</span></span><br><span class="line"><span class="comment">// in the DefaultServeMux.</span></span><br><span class="line"><span class="comment">// The documentation for ServeMux explains how patterns are matched.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span>)</span> &#123;</span><br><span class="line">	DefaultServeMux.HandleFunc(pattern, handler)</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// HandleFunc registers the handler function for the given pattern.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span>)</span> &#123;</span><br><span class="line">	mux.Handle(pattern, HandlerFunc(handler))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Handle registers the handler for the given pattern.</span></span><br><span class="line"><span class="comment">// If a handler already exists for pattern, Handle panics.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">Handle</span><span class="params">(pattern <span class="keyword">string</span>, handler Handler)</span></span> &#123;</span><br><span class="line">	mux.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> mux.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> pattern == <span class="string">""</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"http: invalid pattern"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> handler == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"http: nil handler"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> _, exist := mux.m[pattern]; exist &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"http: multiple registrations for "</span> + pattern)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> mux.m == <span class="literal">nil</span> &#123;</span><br><span class="line">		mux.m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]muxEntry)</span><br><span class="line">	&#125;</span><br><span class="line">	mux.m[pattern] = muxEntry&#123;h: handler, pattern: pattern&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> pattern[<span class="number">0</span>] != <span class="string">'/'</span> &#123;</span><br><span class="line">		mux.hosts = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来是调用：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure></p>
<p>本文不打算追踪启动 <code>server</code> 的整个过程，不了解或者感兴趣的可以看看 <a href="https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/03.4.md" target="_blank" rel="noopener">Go的http包详解</a> 。我们只挑对我们讲解多路复用感兴趣的部分来讲解，下面看看：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sh serverHandler)</span> <span class="title">ServeHTTP</span><span class="params">(rw ResponseWriter, req *Request)</span></span> &#123;</span><br><span class="line">	handler := sh.srv.Handler</span><br><span class="line">	<span class="keyword">if</span> handler == <span class="literal">nil</span> &#123;</span><br><span class="line">		handler = DefaultServeMux</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> req.RequestURI == <span class="string">"*"</span> &amp;&amp; req.Method == <span class="string">"OPTIONS"</span> &#123;</span><br><span class="line">		handler = globalOptionsHandler&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	handler.ServeHTTP(rw, req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的方法表明当我们在调用 <code>http.ListenAndServe(&quot;:8080&quot;, nil)</code> 没有给 <code>handler</code> 的时候，默认使用 <code>DefaultServeMux</code> ，所以上面的例子调用的是 <code>DefaultServeMux</code> 的 <code>ServeHTTP</code>：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ServeHTTP dispatches the request to the handler whose</span></span><br><span class="line"><span class="comment">// pattern most closely matches the request URL.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">ServeHTTP</span><span class="params">(w ResponseWriter, r *Request)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> r.RequestURI == <span class="string">"*"</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> r.ProtoAtLeast(<span class="number">1</span>, <span class="number">1</span>) &#123;</span><br><span class="line">			w.Header().Set(<span class="string">"Connection"</span>, <span class="string">"close"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		w.WriteHeader(StatusBadRequest)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	h, _ := mux.Handler(r)</span><br><span class="line">	h.ServeHTTP(w, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>让我们看看 <code>DefaultServeMux</code> 是如何查找相应的 <code>handler</code> ，看看 <code>match</code> 的实现，只能简单地实现字符串匹配，用起来不够爽吧？<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Find a handler on a handler map given a path string.</span></span><br><span class="line"><span class="comment">// Most-specific (longest) pattern wins.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">match</span><span class="params">(path <span class="keyword">string</span>)</span> <span class="params">(h Handler, pattern <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// Check for exact match first.</span></span><br><span class="line">	v, ok := mux.m[path]</span><br><span class="line">	<span class="keyword">if</span> ok &#123;</span><br><span class="line">		<span class="keyword">return</span> v.h, v.pattern</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Check for longest valid match.</span></span><br><span class="line">	<span class="keyword">var</span> n = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> mux.m &#123;</span><br><span class="line">		<span class="keyword">if</span> !pathMatch(k, path) &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> h == <span class="literal">nil</span> || <span class="built_in">len</span>(k) &gt; n &#123;</span><br><span class="line">			n = <span class="built_in">len</span>(k)</span><br><span class="line">			h = v.h</span><br><span class="line">			pattern = v.pattern</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当然，复杂也可能意味着性能下降，有兴趣的同学可以看看 <a href="https://github.com/julienschmidt/go-http-routing-benchmark/blob/master/README.md" target="_blank" rel="noopener">Go HTTP Router Benchmark</a> ，毕竟系统是拿来用的，不只是拿来写的。不过作为一个合格的程序员，应该学会用轮子，所以让我们看看 <code>gorilla/mux</code> 是怎么实现路由的吧。</p>
<h2 id="gorilla-mux"><a href="#gorilla-mux" class="headerlink" title="gorilla/mux"></a>gorilla/mux</h2><p>一个简单使用的例子（摘自<a href="https://github.com/gorilla/mux#graceful-shutdown" target="_blank" rel="noopener">官方文档</a>）：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"github.com/gorilla/mux"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">YourHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    w.Write([]<span class="keyword">byte</span>(<span class="string">"Gorilla!\n"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := mux.NewRouter()</span><br><span class="line">    <span class="comment">// Routes consist of a path and a handler function.</span></span><br><span class="line">    r.HandleFunc(<span class="string">"/"</span>, YourHandler)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bind to a port and pass our router in</span></span><br><span class="line">    log.Fatal(http.ListenAndServe(<span class="string">":8000"</span>, r))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一些进阶用法：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以匹配 URL 中的变量</span></span><br><span class="line">r := mux.NewRouter()</span><br><span class="line">r.HandleFunc(<span class="string">"/products/&#123;key&#125;"</span>, ProductHandler)</span><br><span class="line">r.HandleFunc(<span class="string">"/articles/&#123;category&#125;/"</span>, ArticlesCategoryHandler)</span><br><span class="line">r.HandleFunc(<span class="string">"/articles/&#123;category&#125;/&#123;id:[0-9]+&#125;"</span>, ArticleHandler)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用匹配的变量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ArticlesCategoryHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    vars := mux.Vars(r)</span><br><span class="line">    w.WriteHeader(http.StatusOK)</span><br><span class="line">    fmt.Fprintf(w, <span class="string">"Category: %v\n"</span>, vars[<span class="string">"category"</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路径前缀</span></span><br><span class="line">r.PathPrefix(<span class="string">"/products/"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Only matches if domain is "www.example.com".</span></span><br><span class="line">r.Host(<span class="string">"www.example.com"</span>)</span><br><span class="line"><span class="comment">// Matches a dynamic subdomain.</span></span><br><span class="line">r.Host(<span class="string">"&#123;subdomain:[a-z]+&#125;.domain.com"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子路由</span></span><br><span class="line">r := mux.NewRouter()</span><br><span class="line">s := r.Host(<span class="string">"www.example.com"</span>).Subrouter()</span><br></pre></td></tr></table></figure></p>
<p>ok，总之它的功能比官方包要强大的多，下面开始源码分析。</p>
<h3 id="mux-go"><a href="#mux-go" class="headerlink" title="mux.go"></a>mux.go</h3><p>先看看其数据结构，与 <code>http.ServeMux</code> 相比，要多出不少东西，我们主要关注 <code>routes</code> 、<code>parent</code> 以及三个 <code>flag</code>：<code>strictSlash</code>、<code>skipClean</code>、<code>useEncodedPath</code>。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This will send all incoming requests to the router.</span></span><br><span class="line"><span class="keyword">type</span> Router <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// Configurable Handler to be used when no route matches.</span></span><br><span class="line">	NotFoundHandler http.Handler</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Configurable Handler to be used when the request method does not match the route.</span></span><br><span class="line">	MethodNotAllowedHandler http.Handler</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Parent route, if this is a subrouter.</span></span><br><span class="line">	parent parentRoute</span><br><span class="line">	<span class="comment">// Routes to be matched, in order.</span></span><br><span class="line">	routes []*Route</span><br><span class="line">	<span class="comment">// Routes by name for URL building.</span></span><br><span class="line">	namedRoutes <span class="keyword">map</span>[<span class="keyword">string</span>]*Route</span><br><span class="line">	<span class="comment">// See Router.StrictSlash(). This defines the flag for new routes.</span></span><br><span class="line">	strictSlash <span class="keyword">bool</span></span><br><span class="line">	<span class="comment">// See Router.SkipClean(). This defines the flag for new routes.</span></span><br><span class="line">	skipClean <span class="keyword">bool</span></span><br><span class="line">	<span class="comment">// If true, do not clear the request context after handling the request.</span></span><br><span class="line">	<span class="comment">// This has no effect when go1.7+ is used, since the context is stored</span></span><br><span class="line">	<span class="comment">// on the request itself.</span></span><br><span class="line">	KeepContext <span class="keyword">bool</span></span><br><span class="line">	<span class="comment">// see Router.UseEncodedPath(). This defines a flag for all routes.</span></span><br><span class="line">	useEncodedPath <span class="keyword">bool</span></span><br><span class="line">	<span class="comment">// Slice of middlewares to be called after a match is found</span></span><br><span class="line">	middlewares []middleware</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中三个 <code>flag</code> 只要看注释就知道它们的作用了，不多解释：</p>
<ul>
<li><p>strictSlash</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StrictSlash defines the trailing slash behavior for new routes. The initial</span></span><br><span class="line"><span class="comment">// value is false.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// When true, if the route path is "/path/", accessing "/path" will perform a redirect</span></span><br><span class="line"><span class="comment">// to the former and vice versa. In other words, your application will always</span></span><br><span class="line"><span class="comment">// see the path as specified in the route.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// When false, if the route path is "/path", accessing "/path/" will not match</span></span><br><span class="line"><span class="comment">// this route and vice versa.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Router)</span> <span class="title">StrictSlash</span><span class="params">(value <span class="keyword">bool</span>)</span> *<span class="title">Router</span></span> &#123;</span><br><span class="line">    r.strictSlash = value</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>skipClean</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SkipClean defines the path cleaning behaviour for new routes. The initial</span></span><br><span class="line"><span class="comment">// value is false. Users should be careful about which routes are not cleaned</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// When true, if the route path is "/path//to", it will remain with the double</span></span><br><span class="line"><span class="comment">// slash. This is helpful if you have a route like: /fetch/http://xkcd.com/534/</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// When false, the path will be cleaned, so /fetch/http://xkcd.com/534/ will</span></span><br><span class="line"><span class="comment">// become /fetch/http/xkcd.com/534</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Router)</span> <span class="title">SkipClean</span><span class="params">(value <span class="keyword">bool</span>)</span> *<span class="title">Router</span></span> &#123;</span><br><span class="line">    r.skipClean = value</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>useEncodedPath</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UseEncodedPath tells the router to match the encoded original path</span></span><br><span class="line"><span class="comment">// to the routes.</span></span><br><span class="line"><span class="comment">// For eg. "/path/foo%2Fbar/to" will match the path "/path/&#123;var&#125;/to".</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If not called, the router will match the unencoded path to the routes.</span></span><br><span class="line"><span class="comment">// For eg. "/path/foo%2Fbar/to" will match the path "/path/foo/bar/to"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Router)</span> <span class="title">UseEncodedPath</span><span class="params">()</span> *<span class="title">Router</span></span> &#123;</span><br><span class="line">    r.useEncodedPath = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>先看看它的 <code>HandleFunc</code> ，首先 <code>NewRoute</code> 创建一个 <code>Route</code> ，然后 <code>Path</code> 为 <code>path</code> 添加一个 <code>matcher</code> ，最后 <code>HandlerFunc</code> 为其设置一个 <code>handler</code> ：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HandleFunc registers a new route with a matcher for the URL path.</span></span><br><span class="line"><span class="comment">// See Route.Path() and Route.HandlerFunc().</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Router)</span> <span class="title">HandleFunc</span><span class="params">(path <span class="keyword">string</span>, f <span class="keyword">func</span>(http.ResponseWriter,</span></span></span><br><span class="line"><span class="function"><span class="params">	*http.Request)</span>) *<span class="title">Route</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> r.NewRoute().Path(path).HandlerFunc(f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其次看看 <code>Router</code> 的 <code>ServeHTTP</code> ，先使用上面说的 <code>flag</code> 对 <code>Request</code> 中的 <code>URL</code> 进行预处理，然后使用 <code>Router</code> 的 <code>Match</code> 方法查找 <code>handler</code>。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ServeHTTP dispatches the handler registered in the matched route.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// When there is a match, the route variables can be retrieved calling</span></span><br><span class="line"><span class="comment">// mux.Vars(request).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Router)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> !r.skipClean &#123;</span><br><span class="line">		path := req.URL.Path</span><br><span class="line">		<span class="keyword">if</span> r.useEncodedPath &#123;</span><br><span class="line">			path = req.URL.EscapedPath()</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Clean path to canonical form and redirect.</span></span><br><span class="line">		<span class="keyword">if</span> p := cleanPath(path); p != path &#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Added 3 lines (Philip Schlump) - It was dropping the query string and #whatever from query.</span></span><br><span class="line">			<span class="comment">// This matches with fix in go 1.2 r.c. 4 for same problem.  Go Issue:</span></span><br><span class="line">			<span class="comment">// http://code.google.com/p/go/issues/detail?id=5252</span></span><br><span class="line">			url := *req.URL</span><br><span class="line">			url.Path = p</span><br><span class="line">			p = url.String()</span><br><span class="line"></span><br><span class="line">			w.Header().Set(<span class="string">"Location"</span>, p)</span><br><span class="line">			w.WriteHeader(http.StatusMovedPermanently)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> match RouteMatch</span><br><span class="line">	<span class="keyword">var</span> handler http.Handler</span><br><span class="line">	<span class="keyword">if</span> r.Match(req, &amp;match) &#123;</span><br><span class="line">		handler = match.Handler</span><br><span class="line">		req = setVars(req, match.Vars)</span><br><span class="line">		req = setCurrentRoute(req, match.Route)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> handler == <span class="literal">nil</span> &amp;&amp; match.MatchErr == ErrMethodMismatch &#123;</span><br><span class="line">		handler = methodNotAllowedHandler()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> handler == <span class="literal">nil</span> &#123;</span><br><span class="line">		handler = http.NotFoundHandler()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !r.KeepContext &#123;</span><br><span class="line">		<span class="keyword">defer</span> contextClear(req)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	handler.ServeHTTP(w, req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>再看看 <code>Router</code> 的 <code>Match</code> 方法，遍历 <code>Router</code> 下的所有 <code>route</code> 看看是否匹配：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Match attempts to match the given request against the router's registered routes.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If the request matches a route of this router or one of its subrouters the Route,</span></span><br><span class="line"><span class="comment">// Handler, and Vars fields of the the match argument are filled and this function</span></span><br><span class="line"><span class="comment">// returns true.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If the request does not match any of this router's or its subrouters' routes</span></span><br><span class="line"><span class="comment">// then this function returns false. If available, a reason for the match failure</span></span><br><span class="line"><span class="comment">// will be filled in the match argument's MatchErr field. If the match failure type</span></span><br><span class="line"><span class="comment">// (eg: not found) has a registered handler, the handler is assigned to the Handler</span></span><br><span class="line"><span class="comment">// field of the match argument.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Router)</span> <span class="title">Match</span><span class="params">(req *http.Request, match *RouteMatch)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, route := <span class="keyword">range</span> r.routes &#123;</span><br><span class="line">		<span class="keyword">if</span> route.Match(req, match) &#123;</span><br><span class="line">			<span class="comment">// Build middleware chain if no error was found</span></span><br><span class="line">			<span class="keyword">if</span> match.MatchErr == <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">for</span> i := <span class="built_in">len</span>(r.middlewares) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">					match.Handler = r.middlewares[i].Middleware(match.Handler)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">// 省略</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这里我们还不能看出 <code>Router</code> 是怎么实现如此强大的路由的，因为重点是 Route。</p>
<h3 id="route-go"><a href="#route-go" class="headerlink" title="route.go"></a>route.go</h3><p>照例看看数据结构，有父路由 <code>parent</code> 、处理器 <code>handler</code> 、匹配器表 <code>matchers</code> 、正则表达式 <code>regexp</code> 以及前面提到的三个 <code>flag</code> 等：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Route stores information to match a request and build URLs.</span></span><br><span class="line"><span class="keyword">type</span> Route <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// Parent where the route was registered (a Router).</span></span><br><span class="line">	parent parentRoute</span><br><span class="line">	<span class="comment">// Request handler for the route.</span></span><br><span class="line">	handler http.Handler</span><br><span class="line">	<span class="comment">// List of matchers.</span></span><br><span class="line">	matchers []matcher</span><br><span class="line">	<span class="comment">// Manager for the variables from host and path.</span></span><br><span class="line">	regexp *routeRegexpGroup</span><br><span class="line">	<span class="comment">// If true, when the path pattern is "/path/", accessing "/path" will</span></span><br><span class="line">	<span class="comment">// redirect to the former and vice versa.</span></span><br><span class="line">	strictSlash <span class="keyword">bool</span></span><br><span class="line">	<span class="comment">// If true, when the path pattern is "/path//to", accessing "/path//to"</span></span><br><span class="line">	<span class="comment">// will not redirect</span></span><br><span class="line">	skipClean <span class="keyword">bool</span></span><br><span class="line">	<span class="comment">// If true, "/path/foo%2Fbar/to" will match the path "/path/&#123;var&#125;/to"</span></span><br><span class="line">	useEncodedPath <span class="keyword">bool</span></span><br><span class="line">	<span class="comment">// The scheme used when building URLs.</span></span><br><span class="line">	buildScheme <span class="keyword">string</span></span><br><span class="line">	<span class="comment">// If true, this route never matches: it is only used to build URLs.</span></span><br><span class="line">	buildOnly <span class="keyword">bool</span></span><br><span class="line">	<span class="comment">// The name used to build URLs.</span></span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	<span class="comment">// Error resulted from building a route.</span></span><br><span class="line">	err error</span><br><span class="line"></span><br><span class="line">	buildVarsFunc BuildVarsFunc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>还记得前面创建 <code>Route</code> 后使用的 <code>Path</code> 方法吧，它能为 <code>URL path</code> 添加一个正则表达式匹配器：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Path adds a matcher for the URL path.</span></span><br><span class="line"><span class="comment">// It accepts a template with zero or more URL variables enclosed by &#123;&#125;. The</span></span><br><span class="line"><span class="comment">// template must start with a "/".</span></span><br><span class="line"><span class="comment">// Variables can define an optional regexp pattern to be matched:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// - &#123;name&#125; matches anything until the next slash.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// - &#123;name:pattern&#125; matches the given regexp pattern.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// For example:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//     r := mux.NewRouter()</span></span><br><span class="line"><span class="comment">//     r.Path("/products/").Handler(ProductsHandler)</span></span><br><span class="line"><span class="comment">//     r.Path("/products/&#123;key&#125;").Handler(ProductsHandler)</span></span><br><span class="line"><span class="comment">//     r.Path("/articles/&#123;category&#125;/&#123;id:[0-9]+&#125;").</span></span><br><span class="line"><span class="comment">//       Handler(ArticleHandler)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Variable names must be unique in a given route. They can be retrieved</span></span><br><span class="line"><span class="comment">// calling mux.Vars(request).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Route)</span> <span class="title">Path</span><span class="params">(tpl <span class="keyword">string</span>)</span> *<span class="title">Route</span></span> &#123;</span><br><span class="line">	r.err = r.addRegexpMatcher(tpl, regexpTypePath)</span><br><span class="line">	<span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里就不打算再深入下去探究如何添加的啦，一来作者水平有限，二来大家有不同的实现方式，所以我们就且停留到这一层吧。下面看看 <code>Route</code> 的 <code>Match</code> ：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Match matches the route against the request.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Route)</span> <span class="title">Match</span><span class="params">(req *http.Request, match *RouteMatch)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> r.buildOnly || r.err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> matchErr error</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Match everything.</span></span><br><span class="line">	<span class="keyword">for</span> _, m := <span class="keyword">range</span> r.matchers &#123;</span><br><span class="line">		<span class="keyword">if</span> matched := m.Match(req, match); !matched &#123;</span><br><span class="line">			<span class="keyword">if</span> _, ok := m.(methodMatcher); ok &#123;</span><br><span class="line">				matchErr = ErrMethodMismatch</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			matchErr = <span class="literal">nil</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> matchErr != <span class="literal">nil</span> &#123;</span><br><span class="line">		match.MatchErr = matchErr</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> match.MatchErr == ErrMethodMismatch &#123;</span><br><span class="line">		<span class="comment">// We found a route which matches request method, clear MatchErr</span></span><br><span class="line">		match.MatchErr = <span class="literal">nil</span></span><br><span class="line">		<span class="comment">// Then override the mis-matched handler</span></span><br><span class="line">		match.Handler = r.handler</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Yay, we have a match. Let's collect some info about it.</span></span><br><span class="line">	<span class="keyword">if</span> match.Route == <span class="literal">nil</span> &#123;</span><br><span class="line">		match.Route = r</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> match.Handler == <span class="literal">nil</span> &#123;</span><br><span class="line">		match.Handler = r.handler</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> match.Vars == <span class="literal">nil</span> &#123;</span><br><span class="line">		match.Vars = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Set variables.</span></span><br><span class="line">	<span class="keyword">if</span> r.regexp != <span class="literal">nil</span> &#123;</span><br><span class="line">		r.regexp.setMatch(req, match, r)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>到这里大家可能会疑惑了，<code>// Match everything</code> 指的是什么，其实一个 <code>Route</code> 可以存在多个 <code>matcher</code>，也就是说，你可能设置了一个这样的路由:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r.HandleFunc(<span class="string">"/products"</span>, ProductsHandler).</span><br><span class="line">  Host(<span class="string">"www.example.com"</span>).</span><br><span class="line">  Methods(<span class="string">"GET"</span>).</span><br><span class="line">  Schemes(<span class="string">"http"</span>)</span><br></pre></td></tr></table></figure></p>
<p>那么这个路由就需要满足上述 4 个 <code>matcher</code> 才能够匹配成功，而 <code>Path</code> 和 <code>Host</code> 都是通过添加 <code>routeRegexp</code> 来实现，<code>Methods</code> 和 <code>Schemes</code> 则分别实现了各自的 <code>matcher</code>：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Path and Host add RegexpMatcher</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Route)</span> <span class="title">Path</span><span class="params">(tpl <span class="keyword">string</span>)</span> *<span class="title">Route</span></span> &#123;</span><br><span class="line">	r.err = r.addRegexpMatcher(tpl, regexpTypePath)</span><br><span class="line">	<span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Route)</span> <span class="title">Host</span><span class="params">(tpl <span class="keyword">string</span>)</span> *<span class="title">Route</span></span> &#123;</span><br><span class="line">	r.err = r.addRegexpMatcher(tpl, regexpTypeHost)</span><br><span class="line">	<span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// methodMatcher matches the request against HTTP methods.</span></span><br><span class="line"><span class="keyword">type</span> methodMatcher []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m methodMatcher)</span> <span class="title">Match</span><span class="params">(r *http.Request, match *RouteMatch)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> matchInArray(m, r.Method)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// schemeMatcher matches the request against URL schemes.</span></span><br><span class="line"><span class="keyword">type</span> schemeMatcher []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m schemeMatcher)</span> <span class="title">Match</span><span class="params">(r *http.Request, match *RouteMatch)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> matchInArray(m, r.URL.Scheme)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>你有可能看了我的分析以后更晕了，但是没关系，你只要记住 <code>gorilla/mux</code> 大致是怎么实现路由的就好：</p>
<ol>
<li><p>使用 <code>Router</code> 的 <code>HandleFunc</code> 、<code>Host</code> 、 <code>Methods</code> 、 <code>Schemes</code> 、 <code>Headers</code> 等方法会创建一个路由并且为其添加相应类型 <code>matcher</code>，当然你也可以使用 <code>MatcherFunc</code> 来创建自己的 <code>matcher</code>。如果你想为一个路由添加多个方法，那么你可以这样：</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r.HandleFunc(<span class="string">"/products"</span>, ProductsHandler).</span><br><span class="line">Host(<span class="string">"www.example.com"</span>).</span><br><span class="line">Methods(<span class="string">"GET"</span>).</span><br><span class="line">Schemes(<span class="string">"http)</span></span><br></pre></td></tr></table></figure>
<p> 因为上面说的每个方法都会返回一个刚创建 Route 的指针，这样你就可以使用 Route 的同名方法来添加 matcher 了。</p>
</li>
<li><p><code>gorilla/mux</code> 会查找 <code>Router</code> 下的 <code>Route</code> 列表，找到是否有无匹配的路由，而 <code>Route</code> 会遍历其 <code>matchers</code> 列表来看看是否满足所有的 <code>matchers</code>，只要一个不匹配，则失败。</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/15/服务计算-gorilla-mux-源码解析/" data-id="cjteawjmm0007nsrpevowyt7v" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Go/">Go</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/03/13/SWAD-Homework1/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          SWAD | Homework1
        
      </div>
    </a>
  
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Go/">Go</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/SWAD/">SWAD</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Go/">Go</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SWAD/">SWAD</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Go/" style="font-size: 10px;">Go</a> <a href="/tags/SWAD/" style="font-size: 10px;">SWAD</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/03/13/SWAD-Homework1/">SWAD | Homework1</a>
          </li>
        
          <li>
            <a href="/2018/11/15/服务计算-gorilla-mux-源码解析/">服务计算 | gorilla/mux 源码解析</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 Sandra<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>